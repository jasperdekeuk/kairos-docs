"use strict";(globalThis.webpackChunkkairos_docs=globalThis.webpackChunkkairos_docs||[]).push([[2859],{10947:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"Development/nvidia","title":"Booting Kairos on Nvidia Jetson ARM","description":"This page contains a reference on how to run Kairos on Nvidia Jetson ARM","source":"@site/docs/Development/nvidia.md","sourceDirName":"Development","slug":"/Development/nvidia","permalink":"/docs/next/Development/nvidia","draft":false,"unlisted":false,"editUrl":"https://github.com/kairos-io/kairos-docs/tree/main/docs/Development/nvidia.md","tags":[],"version":"current","lastUpdatedBy":"Jasper De Keukelaere (imec)","lastUpdatedAt":1765043763000,"sidebarPosition":5,"frontMatter":{"title":"Booting Kairos on Nvidia Jetson ARM","sidebar_label":"Booting Kairos on Nvidia Jetson ARM","sidebar_position":5,"date":"2022-11-13T00:00:00.000Z","description":"This page contains a reference on how to run Kairos on Nvidia Jetson ARM"},"sidebar":"tutorialSidebar","previous":{"title":"Debugging station","permalink":"/docs/next/Development/debugging-station"},"next":{"title":"Enabling Automatic Boot Assessment with Trusted Boot","permalink":"/docs/next/Examples/boot_assessment_trusted_boot"}}');var o=i(74848),r=i(28453);const a={title:"Booting Kairos on Nvidia Jetson ARM",sidebar_label:"Booting Kairos on Nvidia Jetson ARM",sidebar_position:5,date:new Date("2022-11-13T00:00:00.000Z"),description:"This page contains a reference on how to run Kairos on Nvidia Jetson ARM"},s=void 0,l={},d=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Prepare the Kernel",id:"prepare-the-kernel",level:2},{value:"Build from official Nvidia sources",id:"build-from-official-nvidia-sources",level:3},{value:"Build from official linux kernel",id:"build-from-official-linux-kernel",level:3},{value:"Prepare container image (Kairos)",id:"prepare-container-image-kairos",level:2},{value:"Flashing",id:"flashing",level:2},{value:"Replace U-boot (optional)",id:"replace-u-boot-optional",level:3},{value:"Disable Extlinux",id:"disable-extlinux",level:3},{value:"Prepare Partitions",id:"prepare-partitions",level:3},{value:"Configure the SDK",id:"configure-the-sdk",level:3},{value:"Flash",id:"flash",level:3},{value:"Troubleshooting notes",id:"troubleshooting-notes",level:2},{value:"References",id:"references",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.admonition,{title:"Warning",type:"warning",children:(0,o.jsx)(n.p,{children:"Despite the Flavor you may have selected to look into the docs. The Nvidia AGX Orin only works with Ubuntu 20.04"})}),"\n",(0,o.jsx)(n.admonition,{title:"Note",type:"note",children:(0,o.jsxs)(n.p,{children:["Please note that the following page contains only development reference. At the time of writing, we have tried porting Kairos to Jetson Nano eMMC without success. This is due to the old kernel supported (4.9), not properly working with ",(0,o.jsx)(n.code,{children:"EFISTUB"})," and ",(0,o.jsx)(n.code,{children:"U-boot"})," (you can see the ",(0,o.jsx)(n.a,{href:"https://github.com/kairos-io/kairos/issues/45",children:"issue here"}),"). However, the steps outlined ",(0,o.jsx)(n.em,{children:"should"})," be a good reference to port Kairos to those architecture ",(0,o.jsx)(n.em,{children:"when"})," a new kernel version is available. We have tested, and have successfully booted a Jetson Nano with the 5.15 kernel, however, due to the lack of driver support, eMMC partitions are not properly recognized."]})}),"\n",(0,o.jsxs)(n.p,{children:["This page is a development reference in order to boot Kairos in Nvidia Jetson devices. Nvidia Jetson images by default ship ",(0,o.jsx)(n.code,{children:"extlinux"})," as bootloader, without EFI boot. This guide explains how to get instead u-boot to chainload to ",(0,o.jsx)(n.code,{children:"grub2"}),", which can be used to boot and load ",(0,o.jsx)(n.code,{children:"Kairos"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Note that currently there are no official Kairos core images for Jetson images, this page will refer to Jetson Nano eMMC version as the current reference, but the steps should be similar, as outline how to use the Nvidia SDK to flash the OS onboard in the eMMC of the device."}),"\n",(0,o.jsx)(n.p,{children:"The steps involved are:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Prepare the Kernel (if you have one, compatible with ",(0,o.jsx)(n.code,{children:"EFISTUB"}),", you can skip this part)"]}),"\n",(0,o.jsx)(n.li,{children:"Flash u-boot (If the U-boot version support booting efi shells, you might skip this part too)"}),"\n",(0,o.jsx)(n.li,{children:"Prepare the Kairos partitions"}),"\n",(0,o.jsx)(n.li,{children:"Flash the image to the board"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(n.p,{children:["You need the Nvidia SDK and few other dependencies in the system. Note that for the Jetson Nano you can't use the latest SDK version as it is not anymore supporting it. The latest version available with support for Jetson Nano is ",(0,o.jsx)(n.a,{href:"https://developer.nvidia.com/embedded/linux-tegra-r3273",children:"r32.7.3"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Build dependencies\napt update && apt install -y git-core build-essential bc wget xxd kmod flex libelf-dev bison libssl-dev\n\nmkdir build\nbuild_dir=$PWD/build\ncd build\n\n# Get Jetson SDK compatible with Jetson NANO\n\nwget https://developer.nvidia.com/downloads/remetpack-463r32releasev73t210jetson-210linur3273aarch64tbz2 -O Jetson-210_Linux_R32.7.3_aarch64.tbz2\ntar xvf Jetson-210_Linux_R32.7.3_aarch64.tbz2\n"})}),"\n",(0,o.jsx)(n.h2,{id:"prepare-the-kernel",children:"Prepare the Kernel"}),"\n",(0,o.jsxs)(n.p,{children:["The only requirement of the kernel in order to this to work is that has to have ",(0,o.jsx)(n.code,{children:"CONFIG_EFI_STUB"})," and ",(0,o.jsx)(n.code,{children:"CONFIG_EFI"})," enabled."]}),"\n",(0,o.jsxs)(n.p,{children:["The default kernel with the Nvidia Jetson Nano is ",(0,o.jsx)(n.code,{children:"4.9"})," and it turns out to not have those enabled."]}),"\n",(0,o.jsx)(n.h3,{id:"build-from-official-nvidia-sources",children:"Build from official Nvidia sources"}),"\n",(0,o.jsxs)(n.p,{children:["If your kernel is not compiled to boot as ",(0,o.jsx)(n.em,{children:"EFI stub"})," you can refer to the steps below to compile the official Nvidia kernel with ",(0,o.jsx)(n.code,{children:"EFISTUB"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'cd build\nwget https://developer.nvidia.com/downloads/remack-sdksjetpack-463r32releasev73sourcest210publicsourcestbz2 -O public_sources.tbz2\nwget https://developer.nvidia.com/embedded/dlc/l4t-gcc-7-3-1-toolchain-64-bit\ntar xvf https://developer.nvidia.com/embedded/dlc/l4t-gcc-7-3-1-toolchain-64-bit\n# gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/....\nexport CROSS_COMPILE_AARCH64_PATH=$PWD/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/\n\ncd Linux_for_Tegra/source/public\ntar xvf kernel_src.bz2\nmkdir kernel_out\necho "CONFIG_EFI_STUB=y" >> ./kernel/kernel-4.9/arch/arm64/configs/tegra_defconfig\necho "CONFIG_EFI=y" >> ./kernel/kernel-4.9/arch/arm64/configs/tegra_defconfig\n\n# https://forums.developer.nvidia.com/t/kernel-build-script-nvbuild-sh-with-output-dir-option-not-working/173087\nsed -i \'86s/.*/ O_OPT=(O="${KERNEL_OUT_DIR}")/\' nvbuild.sh\n## See workaround for DTB errors in Troubleshooting (edit Kconfig.include..)\n./nvbuild.sh -o $PWD/kernel_out\n'})}),"\n",(0,o.jsx)(n.p,{children:"Note that, with the Jetson NANO, the kernel will fail to boot allocating the memory during the EFI stub boot phase."}),"\n",(0,o.jsx)(n.h3,{id:"build-from-official-linux-kernel",children:"Build from official linux kernel"}),"\n",(0,o.jsxs)(n.p,{children:["Seems the kernel ",(0,o.jsx)(n.code,{children:"5.15"})," boots fine on the Jetson Nano, however, it fails to load eMMC drivers to detect eMMC partitions. A configuration reference can be found ",(0,o.jsx)(n.a,{href:"https://github.com/kairos-io/packages/blob/main/packages/kernels/linux-tegra/config",children:"here"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"build_dir=$PWD/build\ncd build\n\n# Clone the kernel\ngit clone --branch v5.15 --depth 1 https://github.com/torvalds/linux.git kernel-4.9\n\nwget https://developer.nvidia.com/downloads/remack-sdksjetpack-463r32releasev73sourcest210publicsourcestbz2 -O public_sources.tbz2\ntar xvf public_sources.tbz2\nwget https://developer.nvidia.com/embedded/dlc/l4t-gcc-7-3-1-toolchain-64-bit\ntar xvf l4t-gcc-7-3-1-toolchain-64-bit\n\n# Replace the kernel in the SDK\npushd Linux_for_Tegra/source/public && tar xvf kernel_src.tbz2 && rm -rf kernel/kernel-4.9 && mv $build_dir/kernel-4.9 ./kernel/ && popd\n\n# Use the tegra config, patch nvbuild.sh\nmkdir kernel_out && \\\nwget https://raw.githubusercontent.com/kairos-io/packages/main/packages/kernels/linux-tegra/config -O ./kernel/kernel-4.9/arch/arm64/configs/defconfig && \\\nwget https://raw.githubusercontent.com/kairos-io/packages/main/packages/kernels/linux-tegra/nvbuild.sh -O nvbuild.sh && chmod +x nvbuild.sh\n\n# gcc 12 patches\npushd Linux_for_Tegra/source/public/kernel/kernel-4.9 && curl -L https://raw.githubusercontent.com/kairos-io/packages/main/packages/kernels/linux-tegra/patch.patch | patch -p1 && popd\n\n# Build the kernel\npushd Linux_for_Tegra/source/public && \\\n   CROSS_COMPILE_AARCH64_PATH=$build_dir/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/ ./nvbuild.sh -o $PWD/kernel_out\n"})}),"\n",(0,o.jsx)(n.h2,{id:"prepare-container-image-kairos",children:"Prepare container image (Kairos)"}),"\n",(0,o.jsxs)(n.p,{children:["Now we need a container image with the OS image. The image need to contain the kernel and the initramfs generated with ",(0,o.jsx)(n.code,{children:"dracut"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["For instance, given that the kernel is available at ",(0,o.jsx)(n.code,{children:"/boot/Image"}),", and the modules at ",(0,o.jsx)(n.code,{children:"/lib/modules"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-Dockerfile",children:'FROM ....\n\nRUN ln -sf Image /boot/vmlinuz\nRUN kernel=$(ls /lib/modules | head -n1) && \\\n    dracut -f "/boot/initrd-${kernel}" "${kernel}" && \\\n    ln -sf "initrd-${kernel}" /boot/initrd && \\\n    depmod -a "${kernel}"\n'})}),"\n",(0,o.jsx)(n.h2,{id:"flashing",children:"Flashing"}),"\n",(0,o.jsxs)(n.p,{children:["In order to flash to the ",(0,o.jsx)(n.code,{children:"eMMC"})," we need the Nvidia SDK."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"mkdir work\ncd work\nwget https://developer.nvidia.com/downloads/remetpack-463r32releasev73t210jetson-210linur3273aarch64tbz2\ntar xvf Jetson-210_Linux_R32.7.3_aarch64.tbz2\n"})}),"\n",(0,o.jsx)(n.h3,{id:"replace-u-boot-optional",children:"Replace U-boot (optional)"}),"\n",(0,o.jsxs)(n.p,{children:["If the version of ",(0,o.jsx)(n.code,{children:"u-boot"})," is old and doesn't support EFI booting, you can replace the ",(0,o.jsx)(n.code,{children:"u-boot"})," binary like so:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'wget http://download.opensuse.org/ports/aarch64/tumbleweed/repo/oss/aarch64/u-boot-p3450-0000-2023.01-2.1.aarch64.rpm\nmkdir u-boot\ncd u-boot\nrpm2cpio ../u-boot-p3450-0000-2023.01-2.1.aarch64.rpm | cpio -idmv\ncd ..\ncd Linux_for_Tegra\n# "p3450-0000" Depends on your board\ncp -rfv ../u-boot/boot/u-boot.bin bootloader/t210ref/p3450-0000/u-boot.bin\n'})}),"\n",(0,o.jsx)(n.h3,{id:"disable-extlinux",children:"Disable Extlinux"}),"\n",(0,o.jsx)(n.p,{children:"We need to disable extlinux, in order for u-boot to scan for EFI shells:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'# Drop extlinux\necho "" > ./bootloader/extlinux.conf\n'})}),"\n",(0,o.jsx)(n.h3,{id:"prepare-partitions",children:"Prepare Partitions"}),"\n",(0,o.jsxs)(n.p,{children:["We need to prepare the partitions from the container image we want to boot, in order to achieve this, we can use ",(0,o.jsx)(n.code,{children:"osbuilder"}),", which will prepare the ",(0,o.jsx)(n.code,{children:"img"})," files ready to be flashed for the SDK:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"cd Linux_for_Tegra\ndocker run --privileged -e container_image=$IMAGE -v $PWD/bootloader:/bootloader --entrypoint /prepare_nvidia_orin_images.sh -ti --rm quay.io/kairos/auroraboot:latest\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This command should create ",(0,o.jsx)(n.code,{children:"efi.img"}),", ",(0,o.jsx)(n.code,{children:"oem.img"}),", ",(0,o.jsx)(n.code,{children:"persistent.img"}),", ",(0,o.jsx)(n.code,{children:"recovery_partition.img"}),", ",(0,o.jsx)(n.code,{children:"state_partition.img"})," in the ",(0,o.jsx)(n.code,{children:"bootloader"})," directory"]}),"\n",(0,o.jsx)(n.h3,{id:"configure-the-sdk",children:"Configure the SDK"}),"\n",(0,o.jsx)(n.p,{children:"In order to flash the partitions to the eMMC of the board, we need to configure the SDK to write the partitions to the board via its configuration files."}),"\n",(0,o.jsxs)(n.p,{children:["For the Jetson Nano, the configuration file for the partitions is located at ",(0,o.jsx)(n.code,{children:"bootloader/t210ref/cfg/flash_l4t_t210_emmc_p3448.xml"}),", where we replace the ",(0,o.jsx)(n.code,{children:"partition name=APP"})," with:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:' <partition name="esp" type="data">\n            <allocation_policy> sequential </allocation_policy>\n            <filesystem_type> basic </filesystem_type>\n\t    <size> 20971520 </size>\n\t    <file_system_attribute> 0 </file_system_attribute>\n\t    <partition_type_guid> C12A7328-F81F-11D2-BA4B-00A0C93EC93B </partition_type_guid>\n\t    <allocation_attribute> 0x8 </allocation_attribute>\n\t    <percent_reserved> 0 </percent_reserved>\n            <filename> efi.img </filename>\n            <description> **Required.** Contains a redundant copy of CBoot. </description>\n        </partition>\n        \n       <partition name="COS_RECOVERY" type="data">\n            <allocation_policy> sequential </allocation_policy>\n            <filesystem_type> basic </filesystem_type>\n            <size> 2298478592 </size>\n            <allocation_attribute>  0x8 </allocation_attribute>\n            <filename> recovery_partition.img </filename>\n            <description>  </description>\n        </partition>\n        <partition name="COS_STATE" type="data">\n            <allocation_policy> sequential </allocation_policy>\n            <filesystem_type> basic </filesystem_type>\n            <size> 5234491392 </size>\n            <allocation_attribute>  0x8 </allocation_attribute>\n            <filename> state_partition.img </filename>\n            <description>  </description>\n        </partition>\n        <partition name="COS_OEM" type="data">\n            <allocation_policy> sequential </allocation_policy>\n            <filesystem_type> basic </filesystem_type>\n            <size> 67108864 </size>\n            <allocation_attribute>  0x8 </allocation_attribute>\n            <filename> oem.img </filename>\n            <description>  </description>\n        </partition>\n        <partition name="COS_PERSISTENT" type="data">\n            <allocation_policy> sequential </allocation_policy>\n            <filesystem_type> basic </filesystem_type>\n            <size> 2147483648 </size>\n            <allocation_attribute>  0x8 </allocation_attribute>\n            <filename> persistent.img </filename>\n            <description>  </description>\n        </partition>\n'})}),"\n",(0,o.jsx)(n.p,{children:'Note: The order matters here. We want to replace the default "APP" partition with our set of partitions.'}),"\n",(0,o.jsxs)(n.p,{children:["If you didn't changed the default size of the images you should be fine, however, you should check the ",(0,o.jsx)(n.code,{children:"<size></size>"})," of each of the blocks if corresponds to the files generated from your container image:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"stat -c %s bootloader/efi.img\nstat -c %s bootloader/recovery_partition.img\nstat -c %s bootloader/state_partition.img\nstat -c %s bootloader/oem.img\nstat -c %s bootloader/persistent.img\n"})}),"\n",(0,o.jsx)(n.h3,{id:"flash",children:"Flash"}),"\n",(0,o.jsx)(n.p,{children:"Turn the board in recovery mode, depending on the model this process might differ:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Turn off the board"}),"\n",(0,o.jsx)(n.li,{children:"Jump the FCC REC pin to ground"}),"\n",(0,o.jsx)(n.li,{children:"Plug the USB cable"}),"\n",(0,o.jsx)(n.li,{children:"Power on the board"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"If you see the board ready to be flashed, you should see the following:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"$ lsusb\nBus 003 Device 092: ID 0955:7f21 NVIDIA Corp. APX\n"})}),"\n",(0,o.jsx)(n.p,{children:"To flash the configuration to the board, run:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"./flash.sh -r jetson-nano-devkit-emmc mmcblk0p1\n"})}),"\n",(0,o.jsx)(n.h2,{id:"troubleshooting-notes",children:"Troubleshooting notes"}),"\n",(0,o.jsxs)(n.p,{children:["You can use ",(0,o.jsx)(n.code,{children:"picom"})," to see the serial console:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"picocom -b 115200 /dev/ttyUSB0\n"})}),"\n",(0,o.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://docs.nvidia.com/jetson/archives/r35.1/DeveloperGuide/text/SD/SoftwarePackagesAndTheUpdateMechanism.html#update-with-partition-layout-changes",children:"https://docs.nvidia.com/jetson/archives/r35.1/DeveloperGuide/text/SD/SoftwarePackagesAndTheUpdateMechanism.html#update-with-partition-layout-changes"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://docs.nvidia.com/jetson/archives/r34.1/DeveloperGuide/text/SD/Kernel/KernelCustomization.html?highlight=kernel",children:"https://docs.nvidia.com/jetson/archives/r34.1/DeveloperGuide/text/SD/Kernel/KernelCustomization.html?highlight=kernel"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://en.opensuse.org/HCL:Jetson_Nano#Update_Firmware",children:"https://en.opensuse.org/HCL:Jetson_Nano#Update_Firmware"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://nullr0ute.com/2020/11/installing-fedora-on-the-nvidia-jetson-nano/",children:"https://nullr0ute.com/2020/11/installing-fedora-on-the-nvidia-jetson-nano/"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://forums.developer.nvidia.com/t/support-nano-on-openwrt/219168/7",children:"https://forums.developer.nvidia.com/t/support-nano-on-openwrt/219168/7"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>s});var t=i(96540);const o={},r=t.createContext(o);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);