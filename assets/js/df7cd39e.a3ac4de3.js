"use strict";(globalThis.webpackChunkkairos_docs=globalThis.webpackChunkkairos_docs||[]).push([[2850],{28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>i});var o=r(96540);const a={},t=o.createContext(a);function s(e){const n=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(t.Provider,{value:n},e.children)}},37273:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>l,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"Upgrade/kubernetes","title":"Upgrading from Kubernetes","description":"Learn how to upgrade Kairos using Kubernetes","source":"@site/docs/Upgrade/kubernetes.md","sourceDirName":"Upgrade","slug":"/Upgrade/kubernetes","permalink":"/docs/next/Upgrade/kubernetes","draft":false,"unlisted":false,"editUrl":"https://github.com/kairos-io/kairos-docs/tree/main/docs/Upgrade/kubernetes.md","tags":[],"version":"current","lastUpdatedBy":"Jasper De Keukelaere (imec)","lastUpdatedAt":1765043763000,"sidebarPosition":2,"frontMatter":{"title":"Upgrading from Kubernetes","sidebar_label":"From Kubernetes","sidebar_position":2,"date":"2022-11-13T00:00:00.000Z","description":"Learn how to upgrade Kairos using Kubernetes"},"sidebar":"tutorialSidebar","previous":{"title":"Manual","permalink":"/docs/next/Upgrade/manual"},"next":{"title":"Kairos Operator","permalink":"/docs/next/Upgrade/kairos-operator"}}');var a=r(74848),t=r(28453);const s={title:"Upgrading from Kubernetes",sidebar_label:"From Kubernetes",sidebar_position:2,date:new Date("2022-11-13T00:00:00.000Z"),description:"Learn how to upgrade Kairos using Kubernetes"},i=void 0,d={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Upgrading from version X to version Y with Kubernetes",id:"upgrading-from-version-x-to-version-y-with-kubernetes",level:3},{value:"Verify images attestation during upgrades",id:"verify-images-attestation-during-upgrades",level:2},{value:"Customize the upgrade process",id:"customize-the-upgrade-process",level:2},{value:"Upgrade from c3os to Kairos",id:"upgrade-from-c3os-to-kairos",level:2},{value:"What&#39;s next?",id:"whats-next",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Kairos upgrades can be performed either manually or via Kubernetes if the cluster is composed of Kairos nodes. The recommended approach is to use the Kairos operator, which provides a more integrated and Kairos-specific way to manage upgrades."}),"\n",(0,a.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(n.p,{children:["The Kairos operator needs to be deployed on the target cluster. ",(0,a.jsx)(n.a,{href:".././kairos-operator",children:"Read the instructions here"})]}),"\n",(0,a.jsx)(n.h3,{id:"upgrading-from-version-x-to-version-y-with-kubernetes",children:"Upgrading from version X to version Y with Kubernetes"}),"\n",(0,a.jsxs)(n.p,{children:["To trigger an upgrade, create a ",(0,a.jsx)(n.code,{children:"NodeOpUpgrade"})," resource which refers to the image version that you want to upgrade to. This is the recommended approach for upgrading Kairos nodes."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cat <<'EOF' | kubectl apply -f -\n---\napiVersion: operator.kairos.io/v1alpha1\nkind: NodeOpUpgrade\nmetadata:\n  name: kairos-upgrade\n  namespace: default\nspec:\n  # The container image containing the new Kairos version\n  image: quay.io/kairos/@flavor\n  # Example: quay.io/kairos/debian\n\n  # NodeSelector to target specific nodes (optional)\n  nodeSelector:\n    matchLabels:\n      kairos.io/managed: \"true\"\n\n  # Maximum number of nodes that can run the upgrade simultaneously\n  # 0 means run on all nodes at once\n  concurrency: 1\n\n  # Whether to stop creating new jobs when a job fails\n  # Useful for canary deployments\n  stopOnFailure: true\n\n  # Whether to upgrade the active partition (defaults to true)\n  upgradeActive: true\n\n  # Whether to upgrade the recovery partition (defaults to false)\n  upgradeRecovery: false\n\n  # Whether to force the upgrade without version checks\n  force: false\nEOF\n"})}),"\n",(0,a.jsxs)(n.p,{children:['To upgrade the "recovery" partition instead of the active one, set ',(0,a.jsx)(n.code,{children:"upgradeRecovery: true"})," and ",(0,a.jsx)(n.code,{children:"upgradeActive: false"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"spec:\n  # ... other fields ...\n  upgradeActive: false\n  upgradeRecovery: true\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To check all the available versions, see the ",(0,a.jsx)(n.a,{href:"https://quay.io/repository/kairos/opensuse?tab=tags",children:"images"})," available on the container registry, corresponding to the flavor/version selected."]}),"\n",(0,a.jsx)(n.admonition,{title:"Note",type:"note",children:(0,a.jsxs)(n.p,{children:["The Kairos operator provides several upgrade strategies that can be configured through the ",(0,a.jsx)(n.code,{children:"NodeOpUpgrade"}),' resource. You can control concurrency, node selection, and failure handling. The example above shows a "canary upgrade" approach where nodes are upgraded one-by-one with failure detection.']})}),"\n",(0,a.jsx)(n.p,{children:"Jobs will be created for each node that needs to be upgraded. You can monitor the progress:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"$ kubectl  get jobs -A\nNAMESPACE         NAME                             STATUS     COMPLETIONS   DURATION   AGE\ndefault           kairos-upgrade-localhost-wr26f   Running    0/1           24s        24s\n\n$ kubectl  get nodeopupgrades\nNAME             AGE\nkairos-upgrade   5s\n"})}),"\n",(0,a.jsx)(n.p,{children:"Done! We should have all the basics to get our first cluster rolling, but there is much more we can do."}),"\n",(0,a.jsx)(n.h2,{id:"verify-images-attestation-during-upgrades",children:"Verify images attestation during upgrades"}),"\n",(0,a.jsxs)(n.p,{children:["Container images can be signed during the build phase of a CI/CD pipeline using ",(0,a.jsx)(n.a,{href:"https://github.com/sigstore/cosign",children:"Cosign"}),", Kairos signs every artifact as part of the release process."]}),"\n",(0,a.jsxs)(n.p,{children:["To ensure that the images used during upgrades match the expected signatures, ",(0,a.jsx)(n.a,{href:"https://kyverno.io/",children:"Kyverno"})," can be used to set up policies. This is done by checking if the signature is present in the OCI registry and if the image was signed using the specified key. The policy rule check fails if either of these conditions is not met."]}),"\n",(0,a.jsxs)(n.p,{children:["To learn more about this specific Kyverno feature, you can refer to the ",(0,a.jsx)(n.a,{href:"https://kyverno.io/docs/writing-policies/verify-images/",children:"documentation"}),". This allows for the verification of image authenticity directly at the node level prior to upgrading."]}),"\n",(0,a.jsx)(n.p,{children:"A Kyverno policy for standard images might look like the following:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'apiVersion: kyverno.io/v1\nkind: ClusterPolicy\nmetadata:\n  name: check-image\nspec:\n  validationFailureAction: Enforce\n  background: false\n  webhookTimeoutSeconds: 30\n  failurePolicy: Fail\n  rules:\n    - name: check-image\n      match:\n        any:\n        - resources:\n            kinds:\n              - Pod\n      verifyImages:\n      - imageReferences:\n        - "quay.io/kairos/@flavor*"\n        attestors:\n        - entries:\n          # See: https://kyverno.io/docs/writing-policies/verify-images/#keyless-signing-and-verification\n          - keyless:\n              subject: "https://github.com/kairos-io/provider-kairos/.github/workflows/release.yaml@refs/tags/*"\n              issuer: "https://token.actions.githubusercontent.com"\n              rekor:\n                url: https://rekor.sigstore.dev\n'})}),"\n",(0,a.jsxs)(n.p,{children:["To install Kyverno in a Kairos cluster, you can simply use the community ",(0,a.jsx)(n.a,{href:"../../advanced/bundles",children:"bundles"}),". For example, you can use the following installation cloud config file:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"#cloud-config\n\nhostname: kyverno-{{ trunc 4 .MachineID }}\n\n# Specify the bundle to use\nbundles:\n- targets:\n  - run://quay.io/kairos/community-bundles:cert-manager_latest\n  - run://quay.io/kairos/community-bundles:kyverno_latest\n\nusers:\n- name: kairos\n  passwd: kairos\n  groups:\n  - admin\n\nk3s:\n enabled: true\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This configuration file prepares the system with the ",(0,a.jsx)(n.code,{children:"cert-manager"})," and ",(0,a.jsx)(n.code,{children:"kyverno"})," bundles, enabling ",(0,a.jsx)(n.code,{children:"k3s"}),". The Kairos operator can be deployed separately using the instructions in the ",(0,a.jsx)(n.a,{href:".././kairos-operator",children:"Kairos Operator documentation"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"customize-the-upgrade-process",children:"Customize the upgrade process"}),"\n",(0,a.jsxs)(n.p,{children:["For advanced customization, you can use a ",(0,a.jsx)(n.code,{children:"NodeOp"})," resource directly instead of ",(0,a.jsx)(n.code,{children:"NodeOpUpgrade"}),". This gives you full control over the upgrade process and allows you to run custom commands before or after the upgrade:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'apiVersion: operator.kairos.io/v1alpha1\nkind: NodeOp\nmetadata:\n  name: custom-kairos-upgrade\n  namespace: default\nspec:\n  # NodeSelector to target specific nodes\n  nodeSelector:\n    matchLabels:\n      kairos.io/managed: "true"\n\n  # The container image containing the new Kairos version\n  image: quay.io/kairos/@flavor\n  # Example: quay.io/kairos/debian\n\n  # Custom command to execute\n  command:\n    - sh\n    - -c\n    - |\n      set -e\n\n      # Custom pre-upgrade commands\n      echo "Running pre-upgrade tasks..."\n      sed -i \'s/something/to/g\' /host/oem/99_custom.yaml\n\n      # Run the upgrade\n      mount --rbind /host/dev /dev\n      mount --rbind /host/run /run\n      kairos-agent upgrade --source dir:/\n\n      # Custom post-upgrade commands\n      echo "Running post-upgrade tasks..."\n      # Add any post-upgrade logic here\n\n  # Path where the node\'s root filesystem will be mounted\n  hostMountPath: /host\n\n  # Whether to cordon the node before running the operation\n  cordon: true\n\n  # Drain options for pod eviction\n  drainOptions:\n    enabled: true\n    force: false\n    gracePeriodSeconds: 30\n    ignoreDaemonSets: true\n    deleteEmptyDirData: false\n    timeoutSeconds: 300\n\n  # Whether to reboot the node after successful operation\n  rebootOnSuccess: true\n\n  # Maximum number of nodes that can run the operation simultaneously\n  concurrency: 1\n\n  # Whether to stop creating new jobs when a job fails\n  stopOnFailure: true\n'})}),"\n",(0,a.jsx)(n.h2,{id:"upgrade-from-c3os-to-kairos",children:"Upgrade from c3os to Kairos"}),"\n",(0,a.jsxs)(n.p,{children:["If you already have a ",(0,a.jsx)(n.code,{children:"c3os"})," deployment, upgrading to Kairos requires changing every instance of ",(0,a.jsx)(n.code,{children:"c3os"})," to ",(0,a.jsx)(n.code,{children:"kairos"})," in the configuration file. This can be done using a custom ",(0,a.jsx)(n.code,{children:"NodeOp"})," resource:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"apiVersion: operator.kairos.io/v1alpha1\nkind: NodeOp\nmetadata:\n  name: c3os-to-kairos-upgrade\n  namespace: default\nspec:\n  # NodeSelector to target specific nodes\n  nodeSelector:\n    matchLabels:\n      kairos.io/managed: \"true\"\n\n  # The container image containing the new Kairos version\n  image: quay.io/kairos/@flavor\n  # Example: quay.io/kairos/debian\n\n  # Custom command to execute\n  command:\n    - sh\n    - -c\n    - |\n      set -e\n      # Replace c3os with kairos in configuration\n      sed -i 's/c3os/kairos/g' /host/oem/99_custom.yaml\n      # Run the upgrade\n      mount --rbind /host/dev /dev\n      mount --rbind /host/run /run\n      kairos-agent upgrade --source dir:/\n\n  # Path where the node's root filesystem will be mounted\n  hostMountPath: /host\n\n  # Whether to cordon the node before running the operation\n  cordon: true\n\n  # Drain options for pod eviction\n  drainOptions:\n    enabled: true\n    force: false\n    gracePeriodSeconds: 30\n    ignoreDaemonSets: true\n    deleteEmptyDirData: false\n    timeoutSeconds: 300\n\n  # Whether to reboot the node after successful operation\n  rebootOnSuccess: true\n\n  # Maximum number of nodes that can run the operation simultaneously\n  concurrency: 1\n\n  # Whether to stop creating new jobs when a job fails\n  stopOnFailure: true\n"})}),"\n",(0,a.jsx)(n.h2,{id:"whats-next",children:"What's next?"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"../../upgrade/manual",children:"Upgrade nodes manually"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"../../architecture/immutable",children:"Immutable architecture"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"../../installation/p2p",children:"Create decentralized clusters"})}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}}}]);