"use strict";(globalThis.webpackChunkkairos_docs=globalThis.webpackChunkkairos_docs||[]).push([[8483],{28453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>s});var t=o(96540);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}},58557:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"Advanced/after-install","title":"Pushing configuration to a node after installation","description":"Kairos configuration mechanism is based on the cloud-config file given during installation, however, it\'s possible to extend the configuration by providing additional cloud-configs in either /oem or /usr/local/cloud-config.","source":"@site/versioned_docs/version-3.6.0/Advanced/after-install.md","sourceDirName":"Advanced","slug":"/Advanced/after-install","permalink":"/docs/3.6.0/Advanced/after-install","draft":false,"unlisted":false,"editUrl":"https://github.com/kairos-io/kairos-docs/tree/main/versioned_docs/version-3.6.0/Advanced/after-install.md","tags":[],"version":"3.6.0","lastUpdatedBy":"Jasper De Keukelaere (imec)","lastUpdatedAt":1765142882000,"sidebarPosition":1,"frontMatter":{"title":"Pushing configuration to a node after installation","sidebar_label":"After install","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Advanced","permalink":"/docs/3.6.0/category/advanced"},"next":{"title":"Configuring partitions","permalink":"/docs/3.6.0/Advanced/configuring_partitions"}}');var a=o(74848),i=o(28453);const r={title:"Pushing configuration to a node after installation",sidebar_label:"After install",sidebar_position:1},s=void 0,l={},d=[{value:"Manually",id:"manually",level:2},{value:"With Kubernetes",id:"with-kubernetes",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["Kairos configuration mechanism is based on the ",(0,a.jsx)(n.code,{children:"cloud-config "}),"file given during installation, however, it's possible to extend the configuration by providing additional cloud-configs in either ",(0,a.jsx)(n.code,{children:"/oem"})," or ",(0,a.jsx)(n.code,{children:"/usr/local/cloud-config"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["By default, ",(0,a.jsx)(n.code,{children:"kairos"})," reads in lexicographic order YAML cloud-config files in the directories above, indeed, after installation you should be able to see the configuration generated by the interactive-installer as ",(0,a.jsx)(n.code,{children:"/oem/99_custom.yaml"})," in the system."]}),"\n",(0,a.jsx)(n.p,{children:"This mechanism can be used to set and enable persistent configuration on boot after node deployment."}),"\n",(0,a.jsxs)(n.p,{children:["We are going to see how to do that manually or with Kubernetes by using the ",(0,a.jsx)(n.a,{href:"../../Upgrade/kairos-operator",children:"Kairos operator"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"manually",children:"Manually"}),"\n",(0,a.jsxs)(n.p,{children:["SSH into the node and copy the config file you want to add into ",(0,a.jsx)(n.code,{children:"/oem"}),". For instance, to add zram on boot we can copy the following file in ",(0,a.jsx)(n.code,{children:"/oem/100_zram.yaml"})," or ",(0,a.jsx)(n.code,{children:"/usr/local/cloud-config/100_zram.yaml"})," and reboot:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'stages:\n  boot:\n    - name: "zram setup"\n      commands:\n        - modprobe zram\n        - echo lzo > /sys/block/zram0/comp_algorithm\n        - echo 1G > /sys/block/zram0/disksize\n        - mkswap --label zram0 /dev/zram0\n        - swapon --priority 100 /dev/zram0\nname: "zfs setup"\n'})}),"\n",(0,a.jsx)(n.h2,{id:"with-kubernetes",children:"With Kubernetes"}),"\n",(0,a.jsxs)(n.p,{children:["To push configurations to a node, it is recommended to use the ",(0,a.jsx)(n.a,{href:"../../Upgrade/kairos-operator",children:"Kairos operator"})," which provides a more integrated approach for managing Kairos nodes. In the example below, we use a NodeOp to push a swapfile configuration and restart the node afterward."]}),"\n",(0,a.jsx)(n.admonition,{title:"Note",type:"note",children:(0,a.jsx)(n.p,{children:"The Kairos operator provides several deployment strategies that can be configured through the NodeOp resource. You can control concurrency, node selection, and failure handling. The example below shows a simple approach where the operation is applied to every host of the cluster, one-by-one in sequence."})}),"\n",(0,a.jsxs)(n.p,{children:["The following pushes a new cloud config over the ",(0,a.jsx)(n.code,{children:"/oem"})," directory and reboots the node:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'apiVersion: operator.kairos.io/v1alpha1\nkind: NodeOp\nmetadata:\n  name: add-swapfile\n  namespace: default\nspec:\n  # NodeSelector to target specific nodes\n  nodeSelector:\n    matchLabels:\n      kairos.io/managed: "true"\n\n  # The container image to use\n  image: quay.io/kairos/@flavor\n\n  # Custom command to execute\n  command:\n    - sh\n    - -c\n    - |\n      set -e\n\n      # Create swapfile configuration\n      cat > /host/oem/10_swapfile.yaml << \'EOF\'\n      stages:\n       boot:\n         - name: "Setup swapfile"\n           if: "[ ! -e /usr/local/swapfile ]"\n           commands:\n           - dd if=/dev/zero of=/usr/local/swapfile bs=1M count=3K\n           - mkswap /usr/local/swapfile\n         - name: "Enable swapfile"\n           if: "[ -e /usr/local/swapfile ]"\n           commands:\n           - swapon /usr/local/swapfile\n      EOF\n\n      sync\n      # Note: The reboot is handled automatically by the operator when rebootOnSuccess: true\n\n  # Path where the node\'s root filesystem will be mounted\n  hostMountPath: /host\n\n  # Whether to cordon the node before running the operation\n  cordon: true\n\n  # Drain options for pod eviction\n  drainOptions:\n    enabled: true\n    force: false\n    gracePeriodSeconds: 30\n    ignoreDaemonSets: true\n    deleteEmptyDirData: false\n    timeoutSeconds: 300\n\n  # Whether to reboot the node after successful operation\n  rebootOnSuccess: true\n\n  # Maximum number of nodes that can run the operation simultaneously\n  concurrency: 1\n\n  # Whether to stop creating new jobs when a job fails\n  stopOnFailure: true\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);