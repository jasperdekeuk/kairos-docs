"use strict";(globalThis.webpackChunkkairos_docs=globalThis.webpackChunkkairos_docs||[]).push([[2137],{28453:(e,n,a)=>{a.d(n,{R:()=>t,x:()=>r});var i=a(96540);const o={},s=i.createContext(o);function t(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),i.createElement(s.Provider,{value:n},e.children)}},87190:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Advanced/build","title":"Build Kairos appliances","description":"Learn how to build Kairos images from scratch","source":"@site/versioned_docs/version-3.5.7/Advanced/build.md","sourceDirName":"Advanced","slug":"/Advanced/build","permalink":"/docs/3.5.7/Advanced/build","draft":false,"unlisted":false,"editUrl":"https://github.com/kairos-io/kairos-docs/tree/main/versioned_docs/version-3.5.7/Advanced/build.md","tags":[],"version":"3.5.7","lastUpdatedBy":"Jasper De Keukelaere (imec)","lastUpdatedAt":1765142882000,"sidebarPosition":3,"frontMatter":{"title":"Build Kairos appliances","sidebar_label":"Build","sidebar_position":3,"description":"Learn how to build Kairos images from scratch"},"sidebar":"tutorialSidebar","previous":{"title":"Using /opt with System Extensions","permalink":"/docs/3.5.7/Advanced/adding_opt_to_system_extensions"},"next":{"title":"Networking","permalink":"/docs/3.5.7/Advanced/networking"}}');var o=a(74848),s=a(28453);const t={title:"Build Kairos appliances",sidebar_label:"Build",sidebar_position:3,description:"Learn how to build Kairos images from scratch"},r=void 0,l={},d=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Kubernetes",id:"kubernetes",level:3},{value:"Build an ISO",id:"build-an-iso",level:2},{value:"Netboot artifacts",id:"netboot-artifacts",level:2},{value:"Build a Cloud Image",id:"build-a-cloud-image",level:2},{value:"Use the Image in AWS",id:"use-the-image-in-aws",level:3},{value:"Use the Image in OpenStack",id:"use-the-image-in-openstack",level:3},{value:"Build a Cloud Image for Azure",id:"build-a-cloud-image-for-azure",level:2},{value:"How to use the image in Azure",id:"how-to-use-the-image-in-azure",level:3},{value:"Build a Cloud Image for GCE",id:"build-a-cloud-image-for-gce",level:2},{value:"How to use the image in GCE",id:"how-to-use-the-image-in-gce",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.admonition,{title:"Warning",type:"warning",children:(0,o.jsx)(n.p,{children:"This page is a work in progress!\nThe feature is experimental and API is likely going to be subject to changes, don't rely on it yet!"})}),"\n",(0,o.jsx)(n.admonition,{title:"Note",type:"info",children:(0,o.jsxs)(n.p,{children:["This guide provides detailed information about building Kairos images. For a complete guide on creating custom cloud images, including when and how to use these build methods, see ",(0,o.jsx)(n.a,{href:"./creating_custom_cloud_images",children:"Creating Custom Cloud Images"}),"."]})}),"\n",(0,o.jsx)(n.p,{children:"This documentation section describes how the Kairos Kubernetes Native API extensions can be used to build custom appliances or booting medium for Kairos."}),"\n",(0,o.jsx)(n.p,{children:"While it's possible to just run Kairos from the artifacts provided by our release process, there are specific use-cases which needs extended customization, for example when\nadditional kernel modules, or custom, user-defined logic that you might want to embed in the media used for installations."}),"\n",(0,o.jsxs)(n.p,{children:["Note the same can be achieved by using advanced configuration and actually modify the images during installation phase by leveraging the ",(0,o.jsx)(n.code,{children:"chroot"}),' stages that takes place in the image - this is discouraged - as it goes in opposite with the "Single Image", "No infrastructure drift" approach of Kairos. The idea here is to create a system from "scratch" and apply that on the nodes - not to run any specific logic on the node itself.']}),"\n",(0,o.jsx)(n.p,{children:"To achieve that, Kairos provides a set of Kubernetes Native Extensions that allow to programmatically generate Installable mediums, Cloud Images and Netboot artifacts. These provide on-demand customization and exploit Kubernetes patterns to automatically provision nodes using control-plane management clusters - however, the same toolset can be used to build appliances for local development and debugging."}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.a,{href:"../../installation/automated",children:"automated"})," section already shows some examples of how to leverage the Kubernetes Native Extensions and use the Kairos images to build appliances, in this section we will cover and describe in detail how to leverage the CRDs and the Kairos factory to build custom appliances."]}),"\n",(0,o.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(n.p,{children:["When building locally, only ",(0,o.jsx)(n.code,{children:"docker"})," is required to be installed on the system. To build with the Kubernetes Native extensions, a Kubernetes cluster is required and ",(0,o.jsx)(n.code,{children:"helm"})," and ",(0,o.jsx)(n.code,{children:"kubectl"})," installed locally. Note ",(0,o.jsx)(n.a,{href:"https://github.com/kubernetes-sigs/kind",children:"kind"})," can be used as well. The Native extensions don't require any special permission, and run completely unprivileged."]}),"\n",(0,o.jsx)(n.h3,{id:"kubernetes",children:"Kubernetes"}),"\n",(0,o.jsxs)(n.p,{children:["To build with Kubernetes we need to install the Kairos ",(0,o.jsx)(n.code,{children:"osbuilder"})," controller."]}),"\n",(0,o.jsx)(n.p,{children:"The chart depends on cert-manager. You can install the latest version of cert-manager by running the following commands:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f https://github.com/jetstack/cert-manager/releases/latest/download/cert-manager.yaml\nkubectl wait --for=condition=Available deployment --timeout=2m -n cert-manager --all\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Install the Kubernetes charts with ",(0,o.jsx)(n.code,{children:"helm"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"helm repo add kairos https://kairos-io.github.io/helm-charts\nhelm repo update\nhelm install kairos-crd kairos/kairos-crds\nhelm install kairos-osbuilder kairos/osbuilder\n"})}),"\n",(0,o.jsx)(n.p,{children:"Among the things deployed by the helm chart, is also an nginx server which is used to\nserve the artifact files after they are built. See below for more."}),"\n",(0,o.jsx)(n.h2,{id:"build-an-iso",children:"Build an ISO"}),"\n",(0,o.jsxs)(n.p,{children:["To build an ISO, consider the following spec, which provides a hybrid bootable ISO (UEFI/MBR), with the ",(0,o.jsx)(n.code,{children:"core"})," kairos image, adding ",(0,o.jsx)(n.code,{children:"helm"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'kind: Secret\napiVersion: v1\nmetadata:\n  name: cloud-config\nstringData:\n  userdata: |\n    #cloud-config\n    users:\n    - name: "kairos"\n      passwd: "kairos"\n    install:\n      device: "auto"\n      reboot: true\n      poweroff: false\n      auto: true # Required, for automated installations\n---\nkind: OSArtifact\napiVersion: build.kairos.io/v1alpha2\nmetadata:\n  name: hello-kairos\nspec:\n  imageName: "quay.io/kairos/kairos-standard:latest"\n  iso: true\n  bundles:\n  # Bundles available at: https://packages.kairos.io/Kairos/\n  - quay.io/kairos/packages:helm-utils-3.10.1\n  cloudConfigRef:\n    name: cloud-config\n    key: userdata\n  exporters:\n    - template:\n        spec:\n            restartPolicy: Never\n            containers:\n            - name: upload\n              image: quay.io/curl/curl\n              command:\n              - /bin/sh\n              args:\n              - -c\n              - |\n                  for f in $(ls /artifacts)\n                  do\n                  curl -T /artifacts/$f http://osartifactbuilder-operator-osbuilder-nginx/upload/$f\n                  done\n              volumeMounts:\n              - name: artifacts\n                mountPath: /artifacts\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Apply the manifest with ",(0,o.jsx)(n.code,{children:"kubectl apply"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Note, the CRD allows to specify a custom Cloud config file, ",(0,o.jsx)(n.a,{href:"../../reference/configuration",children:"check out the full configuration reference"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["As mentioned above, there is an nginx server that will serve the built artifacts as soon as they are ready.\nBy default, it is exposed with a ",(0,o.jsx)(n.code,{children:"NodePort"})," type of service. Use the following commands\nto get its URL:"]}),"\n",(0,o.jsx)(n.p,{children:"The controller will create a pod that builds the ISO ( we can follow the process by tailing to the containers log ) and later makes it accessible to its own dedicated service (nodeport by default):"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"$ PORT=$(kubectl get svc osartifactbuilder-operator-osbuilder-nginx -o json | jq '.spec.ports[0].nodePort')\n$ curl http://<node-ip>:$PORT/hello-kairos.iso -o output.iso\n"})}),"\n",(0,o.jsx)(n.h2,{id:"netboot-artifacts",children:"Netboot artifacts"}),"\n",(0,o.jsxs)(n.p,{children:["It is possible to use the CRD to prepare artifacts required for netbooting, by enabling ",(0,o.jsx)(n.code,{children:"netboot: true"})," for instance:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'kind: OSArtifact\nmetadata:\n  name: hello-kairos\nspec:\n  imageName: "quay.io/kairos/kairos-core:latest"\n  netboot: true\n  netbootURL: ...\n  bundles: ...\n  cloudConfig: ...\n  exporters: ...\n'})}),"\n",(0,o.jsx)(n.h2,{id:"build-a-cloud-image",children:"Build a Cloud Image"}),"\n",(0,o.jsx)(n.p,{children:"Cloud images are images that automatically boots into recovery mode and can be used to deploy whatever image you want to the VM.\nCustom user-data from the Cloud provider is automatically retrieved, additionally the CRD allows to embed a custom cloudConfig so that we can use to make configuration permanent also for VM images running outside a cloud provider."}),"\n",(0,o.jsx)(n.p,{children:"A Cloud Image boots in QEMU and also in AWS, consider:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'kind: Secret\napiVersion: v1\nmetadata:\n  name: cloud-config\nstringData:\n  userdata: |\n    #cloud-config\n    users:\n    - name: "kairos"\n      passwd: "kairos"\n    name: "Default deployment"\n    stages:\n      boot:\n      - name: "Repart image"\n        layout:\n          device:\n            label: COS_RECOVERY\n          add_partitions:\n            - fsLabel: COS_STATE\n              size: 16240 # At least 16gb\n              pLabel: state\n      - name: "Repart image"\n        layout:\n          device:\n            label: COS_RECOVERY\n          add_partitions:\n            - fsLabel: COS_PERSISTENT\n              pLabel: persistent\n              size: 0 # all space\n      - if: \'[ -f "/run/cos/recovery_mode" ] && [ ! -e /usr/local/.deployed ]\'\n        name: "Deploy kairos"\n        commands:\n          - kairos-agent --debug reset --unattended\n          - touch /usr/local/.deployed\n          - reboot\n---\napiVersion: build.kairos.io/v1alpha1\nkind: OSArtifact\nmetadata:\n  name: hello-kairos\nspec:\n  imageName: "quay.io/kairos/kairos-core:latest"\n  cloudImage: true\n  cloudConfigRef:\n    name: cloud-config\n    key: userdata\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Note: Since the image come with only the ",(0,o.jsx)(n.code,{children:"recovery"})," system populated, we need to apply a cloud-config similar to this one which tells which container image we want to deploy.\nThe first steps when the machine boots into is to actually create the partitions needed to boot the active and the passive images, and its populated during the first boot."]}),"\n",(0,o.jsxs)(n.p,{children:["After applying the spec, the controller will create a Kubernetes Job which runs the build process and\nthen copy the produced ",(0,o.jsx)(n.code,{children:"hello-kairos.raw"})," file to the nginx server (see above). Alternatively you may configure your own job to copy the content elsewhere. This file is an EFI bootable raw disk, bootable in QEMU and compatible with AWS which automatically provisions the node:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"$ PORT=$(kubectl get svc osartifactbuilder-operator-osbuilder-nginx -o json | jq '.spec.ports[0].nodePort')\n$ curl http://<node-ip>:$PORT/hello-kairos.raw -o output.raw\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Note, in order to use the image with QEMU, we need to resize the disk at least to 32GB, this can be done with the CRD by setting ",(0,o.jsx)(n.code,{children:"diskSize: 32000"})," or by truncating the file after downloading:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'truncate -s "+$((32000*1024*1024))" hello-kairos.raw \n'})}),"\n",(0,o.jsx)(n.p,{children:"This is not required if running the image in the Cloud as providers usually resize the disk during import or creation of new instances."}),"\n",(0,o.jsxs)(n.p,{children:["To run the image locally with QEMU we need ",(0,o.jsx)(n.code,{children:"qemu"})," installed in the system, and we need to be able to run VMs with EFI, for example:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"qemu-system-x86_64 -m 2048 -bios /usr/share/qemu/ovmf-x86_64.bin -drive if=virtio,media=disk,file=output.raw\n"})}),"\n",(0,o.jsx)(n.h3,{id:"use-the-image-in-aws",children:"Use the Image in AWS"}),"\n",(0,o.jsx)(n.p,{children:"To consume the image, copy it into an s3 bucket:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"aws s3 cp <cos-raw-image> s3://<your_s3_bucket>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Create a ",(0,o.jsx)(n.code,{children:"container.json"})," file referring to it:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n"Description": "Kairos custom image",\n"Format": "raw",\n"UserBucket": {\n  "S3Bucket": "<your_s3_bucket>",\n  "S3Key": "<cos-raw-image>"\n}\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Import the image:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'aws ec2 import-snapshot --description "Kairos custom image" --disk-container file://container.json\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Follow the procedure described in ",(0,o.jsx)(n.a,{href:"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/creating-an-ami-ebs.html#creating-launching-ami-from-snapshot",children:"AWS docs"})," to register an AMI from snapshot. Use all default settings except for the firmware, set to force to UEFI boot."]}),"\n",(0,o.jsxs)(n.p,{children:["Since release v3.3.0, Kairos release pipeline is pushing a public image to AWS, which you can use. Read how to deploy Kairos using an AMI (the released or a custom one), in the ",(0,o.jsx)(n.a,{href:"../../installation/aws",children:"relevant page"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"use-the-image-in-openstack",children:"Use the Image in OpenStack"}),"\n",(0,o.jsx)(n.p,{children:"First get the generated image:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"$ PORT=$(kubectl get svc osartifactbuilder-operator-osbuilder-nginx -o json | jq '.spec.ports[0].nodePort')\n$ curl http://<node-ip>:$PORT/hello-kairos.raw -o output.raw\n"})}),"\n",(0,o.jsx)(n.p,{children:"Import the image to Glance:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"osp image create hello-kairos-image --property hw_firmware_type='uefi' --file ./hello-kairos.raw\n"})}),"\n",(0,o.jsx)(n.p,{children:"Image could be used to create an OpenStack instance."}),"\n",(0,o.jsx)(n.p,{children:"Set the property to force to UEFI boot. If not kairos won't be able to start and you could be prompted endlessly by :"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"Booting from hard drive...\n"})}),"\n",(0,o.jsx)(n.h2,{id:"build-a-cloud-image-for-azure",children:"Build a Cloud Image for Azure"}),"\n",(0,o.jsx)(n.p,{children:"Similarly we can build images for Azure, consider:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'apiVersion: build.kairos.io/v1alpha1\nkind: OSArtifact\nmetadata:\n  name: hello-kairos\nspec:\n  imageName: "quay.io/kairos/kairos-core:latest"\n  azureImage: true\n  ...\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Will generate a compressed disk ",(0,o.jsx)(n.code,{children:"hello-kairos-azure.vhd"})," ready to be used in Azure."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"$ PORT=$(kubectl get svc osartifactbuilder-operator-osbuilder-nginx -o json | jq '.spec.ports[0].nodePort')\n$ curl http://<node-ip>:$PORT/hello-kairos-azure.vhd -o output.vhd\n"})}),"\n",(0,o.jsx)(n.h3,{id:"how-to-use-the-image-in-azure",children:"How to use the image in Azure"}),"\n",(0,o.jsxs)(n.p,{children:["Upload the Azure Cloud VHD disk in  ",(0,o.jsx)(n.code,{children:".vhda"}),"  format to your bucket:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"az storage copy --source <cos-azure-image> --destination https://<account>.blob.core.windows.net/<container>/<destination-azure-image>\n"})}),"\n",(0,o.jsx)(n.p,{children:"Import the disk:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"az image create --resource-group <resource-group> --source https://<account>.blob.core.windows.net/<container>/<destination-azure-image> --os-type linux --hyper-v-generation v2 --name <image-name>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Note:  There is currently no way of altering the boot disk of an Azure VM via GUI, use the ",(0,o.jsx)(n.code,{children:"az"})," to launch the VM with an expanded OS disk if needed"]}),"\n",(0,o.jsx)(n.h2,{id:"build-a-cloud-image-for-gce",children:"Build a Cloud Image for GCE"}),"\n",(0,o.jsx)(n.p,{children:"Similarly we can build images for GCE, consider:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'apiVersion: build.kairos.io/v1alpha1\nkind: OSArtifact\nmetadata:\n  name: hello-kairos\nspec:\n  imageName: "quay.io/kairos/kairos-core:latest"\n  gceImage: true\n  ...\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Will generate a compressed disk ",(0,o.jsx)(n.code,{children:"hello-kairos.gce.raw.tar.gz"})," ready to be used in GCE."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"$ PORT=$(kubectl get svc osartifactbuilder-operator-osbuilder-nginx -o json | jq '.spec.ports[0].nodePort')\n$ curl http://<node-ip>:$PORT/hello-kairos.gce.raw.tar.gz -o output.gce.raw.tar.gz\n"})}),"\n",(0,o.jsx)(n.h3,{id:"how-to-use-the-image-in-gce",children:"How to use the image in GCE"}),"\n",(0,o.jsx)(n.p,{children:"To upload the image in GCE (compressed):"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"gsutil cp <cos-gce-image> gs://<your_bucket>/\n"})}),"\n",(0,o.jsx)(n.p,{children:"Import the disk:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"gcloud compute images create <new_image_name> --source-uri=<your_bucket>/<cos-gce-image> --guest-os-features=UEFI_COMPATIBLE\n"})}),"\n",(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"https://cloud.google.com/container-optimized-os/docs/how-to/create-configure-instance#using_cloud-init_with_the_cloud_config_format",children:"here how to use a cloud-init with Google cloud"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);