"use strict";(globalThis.webpackChunkkairos_docs=globalThis.webpackChunkkairos_docs||[]).push([[4918],{28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>s});var a=r(96540);const t={},i=a.createContext(t);function o(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),a.createElement(i.Provider,{value:n},e.children)}},32315:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"Architecture/container","title":"Container based","description":"Discover how Kairos delivers its entire OS as a container image, enabling predictable upgrades and simple version control.","source":"@site/docs/Architecture/container.md","sourceDirName":"Architecture","slug":"/Architecture/container","permalink":"/docs/next/Architecture/container","draft":false,"unlisted":false,"editUrl":"https://github.com/kairos-io/kairos-docs/tree/main/docs/Architecture/container.md","tags":[],"version":"current","lastUpdatedBy":"Jasper De Keukelaere (imec)","lastUpdatedAt":1765043763000,"sidebarPosition":2,"frontMatter":{"title":"Container based","sidebar_label":"Container","description":"Discover how Kairos delivers its entire OS as a container image, enabling predictable upgrades and simple version control.","sidebar_position":2,"date":"2022-11-13T00:00:00.000Z"},"sidebar":"tutorialSidebar","previous":{"title":"Immutable","permalink":"/docs/next/Architecture/immutable"},"next":{"title":"Cloud init based","permalink":"/docs/next/Architecture/cloud-init"}}');var t=r(74848),i=r(28453);const o={title:"Container based",sidebar_label:"Container",description:"Discover how Kairos delivers its entire OS as a container image, enabling predictable upgrades and simple version control.",sidebar_position:2,date:new Date("2022-11-13T00:00:00.000Z")},s=void 0,c={},l=[{value:"A/B Upgrades",id:"ab-upgrades",level:2},{value:"Benefits",id:"benefits",level:2},{value:"Container Image based OS",id:"container-image-based-os",level:2},{value:"See also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Kairos is a container-based operating system (OS)."}),"\n",(0,t.jsx)(n.p,{children:"A container-based operating system is an OS that is shipped via containers. Indeed, if it happens to be based on Linux (most probably), you can run the container image as well on your Docker daemon. The image being booted is the container, which contains all the required pieces in order to boot (Kernel, Initrd, Init system). There is no real container runtime running the image. The container is used to construct an image internally that is then used to boot the system in an A/B fashion, so there is no overhead introduced. The system being booted is actually a snapshot of the container."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Single-image"})," The OS is a single container image which contains all the OS components, including Kernel and Initrd."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tamper-proof upgrades"})," Upgrades are atomic, A/B swaps with fallback mechanisms and automatic boot assessment."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Distributed via container registries"})," Bootable images are standard OCI artifacts that can be hosted in any container registry."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Platform Engineer-friendly"})," Adapt the infrastructure to your needs by plugging images into your already-existing workflow pipeline. Customizing an immutable OS becomes as easy as writing a Dockerfile."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"ab-upgrades",children:"A/B Upgrades"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://user-images.githubusercontent.com/2420543/197806999-587632a1-0292-44df-bb8f-176ff702f62d.png",alt:"upgrade"})}),"\n",(0,t.jsx)(n.p,{children:"Upgrades are atomic operations that can be triggered manually or via Kubernetes. The node will create a transition image that will be swapped for the Active system, and the Active system becomes Passive. This ensures tamper-proof upgrades and automated fallback and boot assessment strategies are in place to automatically boot from the fallback system. The recovery image can be furthermore exploited to completely automatize node recovery."}),"\n",(0,t.jsx)(n.h2,{id:"benefits",children:"Benefits"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Container registries are already widely supported and used by anyone."}),"\n",(0,t.jsx)(n.li,{children:"Reduce infrastructure drift, by pushing upgrades as single images, with atomic upgrades."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If you are operating a Kubernetes cluster and deploying applications on top, chances are that you already have a container registry deployed somewhere and configured to store them or manage your infrastructure stack. By using container images, you can reuse the same infrastructure to propagate upgrades to the nodes and handle customizations."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://user-images.githubusercontent.com/2420543/197808767-e213709d-af21-4e32-9a78-818f34170077.png",alt:"kairos-factory"})}),"\n",(0,t.jsx)(n.p,{children:"Container images can be extended after a build by using standard container building practices and can seamlessly plug into your existing pipelines. Kairos allows you to seamlessly upgrade to container images that are derived from other versions."}),"\n",(0,t.jsx)(n.p,{children:"We believe that bringing rollbacks, or incremental patches upgrades increases the exposure to infrastructure drift. In opposition, immutable, single images are deployed to the nodes as they were apps - no more discrepancies in your nodes - no need of configuration management tools like Chef, Ansible, or alikes."}),"\n",(0,t.jsx)(n.p,{children:"This means that to customize a Kairos version, all that is required is to build a standard container image with a plain Dockerfile\u2014plus, the bits that are actually needed - we can't touch a system as we are typically used to."}),"\n",(0,t.jsx)(n.p,{children:'If you are familiar with Dockerfiles, then you are good to go to roll your own custom OS version to provision in the nodes. That removes any friction to questions like, "How do I add this package to my nodes?", or more complex ones as, "How can I replace with my own Kernel?".'}),"\n",(0,t.jsx)(n.h2,{id:"container-image-based-os",children:"Container Image based OS"}),"\n",(0,t.jsxs)(n.p,{children:["The Image support matrix in ",(0,t.jsx)(n.a,{href:"../../reference/image_matrix",children:"here"})," lists all the container images built from our CI on every release of Kairos."]}),"\n",(0,t.jsx)(n.p,{children:"To inspect an image and run it locally, you can use a container engine like Docker or Podman:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"docker pull quay.io/kairos/kairos-core:latest\n"})}),"\n",(0,t.jsx)(n.p,{children:"We can run it locally with docker as a container to inspect it, as it is runnable:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'$ docker run -ti --rm quay.io/kairos/kairos-core:latest\n$ cat /etc/os-release\n...\nKAIROS_NAME="kairos-core-@flavor"\nKAIROS_VERSION="latest"\nKAIROS_ID="kairos"\nKAIROS_ID_LIKE="kairos-core-@flavor"\nKAIROS_VERSION_ID="latest"\nKAIROS_PRETTY_NAME="kairos-core-@flavor latest"\nKAIROS_BUG_REPORT_URL="https://github.com/kairos-io/kairos/issues"\nKAIROS_HOME_URL="https://github.com/kairos-io/kairos"\nKAIROS_IMAGE_REPO="quay.io/kairos/kairos-core:latest\nKAIROS_IMAGE_LABEL="latest"\nKAIROS_GITHUB_REPO="kairos-io/kairos"\nKAIROS_VARIANT="core"\nKAIROS_FLAVOR="@flavor"\n'})}),"\n",(0,t.jsx)(n.p,{children:"And check out things like what's the kernel inside:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ ls -liah /boot/\ntotal 102M\n6692018 drwxr-xr-x 2 root root 4.0K Apr 16  2020 .\n6817515 drwxr-xr-x 1 root root 4.0K Oct 10 16:11 ..\n6692019 -rw-r--r-- 1 root root   65 Apr 16  2020 .vmlinuz-5.14.21-150400.24.21-default.hmac\n6692020 -rw-r--r-- 1 root root 4.9M Apr 16  2020 System.map-5.14.21-150400.24.21-default\n6692021 -rw-r--r-- 1 root root 1.7K Apr 16  2020 boot.readme\n6692022 -rw-r--r-- 1 root root 245K Apr 16  2020 config-5.14.21-150400.24.21-default\n6692023 lrwxrwxrwx 1 root root   35 Apr 16  2020 initrd -> initrd-5.14.21-150400.24.21-default\n6692024 -rw------- 1 root root  69M Apr 16  2020 initrd-5.14.21-150400.24.21-default\n6692025 -rw-r--r-- 1 root root 443K Apr 16  2020 symvers-5.14.21-150400.24.21-default.gz\n6692026 -rw-r--r-- 1 root root  484 Apr 16  2020 sysctl.conf-5.14.21-150400.24.21-default\n6692027 -rw-r--r-- 1 root root  17M Apr 16  2020 vmlinux-5.14.21-150400.24.21-default.gz\n6692028 lrwxrwxrwx 1 root root   36 Apr 16  2020 vmlinuz -> vmlinuz-5.14.21-150400.24.21-default\n6692029 -rw-r--r-- 1 root root  11M Apr 16  2020 vmlinuz-5.14.21-150400.24.21-default\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The CI process generates bootable medium by the container images, and similarly, we can modify this image to introduce our changes and remaster an ISO as described in ",(0,t.jsx)(n.a,{href:"../../installation/automated",children:"Automated installation"}),", but that can be resumed in the following steps:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'$ docker run -ti --name custom-container quay.io/kairos/kairos-core:latest\n# # Do your changes inside the container..\n# echo "foo" > /foo\n# ...\n# exit\n$ docker commit custom-container custom-image\n > sha256:37176f104a870480f9c3c318ab51f6c456571b6612b6a47b96af71b95a0a27c7\n# Builds an ISO from it\n$ docker run -v $PWD:/cOS -v /var/run/docker.sock:/var/run/docker.sock -i --rm quay.io/kairos/auroraboot:latest --debug build-iso --name "custom-iso" --date=false --output /cOS/ custom-image\n > ...\n > ...\n > xorriso : UPDATE : Writing:     147456s   84.0%   fifo 100%  buf  50%   60.5xD\n > ISO image produced: 175441 sectors\n > Written to medium : 175472 sectors at LBA 48\n > Writing to \'/cOS/custom-iso.iso\' completed successfully.\n$ ls\ncustom-iso.iso custom-iso.iso.sha256\n'})}),"\n",(0,t.jsx)(n.p,{children:"In order to go further and upgrade nodes using this image, now the only requirement is to push it in a container registry and upgrade the nodes using that container image."}),"\n",(0,t.jsxs)(n.p,{children:["For upgrading to a container image see ",(0,t.jsx)(n.a,{href:"../../upgrade/manual",children:"manual upgrades"})," and ",(0,t.jsx)(n.a,{href:"../../upgrade/kubernetes",children:"kubernetes upgrades"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"../../installation/automated#iso-remastering",children:"ISO remastering"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);