"use strict";(globalThis.webpackChunkkairos_docs=globalThis.webpackChunkkairos_docs||[]).push([[3115],{11470:(e,n,t)=>{t.d(n,{A:()=>w});var a=t(96540),r=t(34164),s=t(17559),o=t(23104),l=t(56347),i=t(205),c=t(57485),d=t(31682),u=t(70679);function h(e){return a.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,a.useMemo)(()=>{const e=n??function(e){return h(e).map(({props:{value:e,label:n,attributes:t,default:a}})=>({value:e,label:n,attributes:t,default:a}))}(t);return function(e){const n=(0,d.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function m({value:e,tabValues:n}){return n.some(n=>n.value===e)}function g({queryString:e=!1,groupId:n}){const t=(0,l.W6)(),r=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(r),(0,a.useCallback)(e=>{if(!r)return;const n=new URLSearchParams(t.location.search);n.set(r,e),t.replace({...t.location,search:n.toString()})},[r,t])]}function b(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,s=p(e),[o,l]=(0,a.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:s})),[c,d]=g({queryString:t,groupId:r}),[h,b]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,r]=(0,u.Dv)(n);return[t,(0,a.useCallback)(e=>{n&&r.set(e)},[n,r])]}({groupId:r}),x=(()=>{const e=c??h;return m({value:e,tabValues:s})?e:null})();(0,i.A)(()=>{x&&l(x)},[x]);return{selectedValue:o,selectValue:(0,a.useCallback)(e=>{if(!m({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),b(e)},[d,b,s]),tabValues:s}}var x=t(92303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=t(74848);function k({className:e,block:n,selectedValue:t,selectValue:a,tabValues:s}){const l=[],{blockElementScrollPositionUntilNextRender:i}=(0,o.a_)(),c=e=>{const n=e.currentTarget,r=l.indexOf(n),o=s[r].value;o!==t&&(i(n),a(o))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},e),children:s.map(({value:e,label:n,attributes:a})=>(0,f.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{l.push(e)},onKeyDown:d,onClick:c,...a,className:(0,r.A)("tabs__item",v.tabItem,a?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function y({lazy:e,children:n,selectedValue:t}){const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=s.find(e=>e.props.value===t);return e?(0,a.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:s.map((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function j(e){const n=b(e);return(0,f.jsxs)("div",{className:(0,r.A)(s.G.tabs.container,"tabs-container",v.tabList),children:[(0,f.jsx)(k,{...n,...e}),(0,f.jsx)(y,{...n,...e})]})}function w(e){const n=(0,x.A)();return(0,f.jsx)(j,{...e,children:h(e.children)},String(n))}},19365:(e,n,t)=>{t.d(n,{A:()=>o});t(96540);var a=t(34164);const r={tabItem:"tabItem_Ymn6"};var s=t(74848);function o({children:e,hidden:n,className:t}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,t),hidden:n,children:e})}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var a=t(96540);const r={},s=a.createContext(r);function o(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(s.Provider,{value:n},e.children)}},50486:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>u});const a=JSON.parse('{"id":"Reference/entangle","title":"Entangle CRDs","description":"Inter-connecting Kubernetes clusters without the need of exposing any service to the public via E2E P2P encrypted networks.","source":"@site/versioned_docs/version-3.6.0/Reference/entangle.md","sourceDirName":"Reference","slug":"/Reference/entangle","permalink":"/kairos-docs/docs/3.6.0/Reference/entangle","draft":false,"unlisted":false,"editUrl":"https://github.com/kairos-io/kairos-docs/tree/main/versioned_docs/version-3.6.0/Reference/entangle.md","tags":[],"version":"3.6.0","lastUpdatedBy":"Jasper De Keukelaere (imec)","lastUpdatedAt":1765142882000,"sidebarPosition":8,"frontMatter":{"title":"Entangle CRDs","sidebar_label":"Entangle","sidebar_position":8,"date":"2022-11-13T00:00:00.000Z","description":"Inter-connecting Kubernetes clusters without the need of exposing any service to the public via E2E P2P encrypted networks."},"sidebar":"tutorialSidebar","previous":{"title":"Recovery mode","permalink":"/kairos-docs/docs/3.6.0/Reference/recovery_mode"},"next":{"title":"Frequently asked questions","permalink":"/kairos-docs/docs/3.6.0/Reference/faq"}}');var r=t(74848),s=t(28453),o=t(11470),l=t(19365);const i={title:"Entangle CRDs",sidebar_label:"Entangle",sidebar_position:8,date:new Date("2022-11-13T00:00:00.000Z"),description:"Inter-connecting Kubernetes clusters without the need of exposing any service to the public via E2E P2P encrypted networks."},c=void 0,d={},u=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Install the CRD and <code>entangle</code>",id:"install-the-crd-and-entangle",level:3},{value:"Install <code>entangle-proxy</code>",id:"install-entangle-proxy",level:3},{value:"Controlling a remote cluster",id:"controlling-a-remote-cluster",level:2},{value:"Generating a network token",id:"generating-a-network-token",level:3},{value:"Managed cluster",id:"managed-cluster",level:3},{value:"Control",id:"control",level:3},{value:"Expose services",id:"expose-services",level:2},{value:"Deployment",id:"deployment",level:3},{value:"Sidecar injection",id:"sidecar-injection",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.admonition,{title:"Network",type:"warning",children:(0,r.jsx)(n.p,{children:"This feature is experimental and has only been tested on local setups. Run in production servers at your own risk.\nFeedback and bug reports are welcome, as we are improving the p2p aspects of Kairos."})}),"\n",(0,r.jsxs)(n.p,{children:["Kairos has two Kubernetes Native extensions ( ",(0,r.jsx)(n.a,{href:"https://github.com/kairos-io/entangle",children:"entangle"})," and ",(0,r.jsx)(n.a,{href:"https://github.com/kairos-io/entangle-proxy",children:"entangle-proxy"})," ) that allows to interconnect services between different clusters via P2P with a shared secret."]}),"\n",(0,r.jsxs)(n.p,{children:["The clusters won't need to do any specific setting in order to establish a connection, as it uses ",(0,r.jsx)(n.a,{href:"https://github.com/libp2p/go-libp2p",children:"libp2p"})," to establish a connection between the nodes."]}),"\n",(0,r.jsxs)(n.p,{children:["Entangle can be used to connect services running on different clusters or can be used with ",(0,r.jsx)(n.code,{children:"entangle-proxy"})," to control another cluster remotely via P2P."]}),"\n",(0,r.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(n.p,{children:["To ",(0,r.jsx)(n.code,{children:"entangle"})," two or more clusters you need one or more Kubernetes cluster; ",(0,r.jsx)(n.code,{children:"entangle"})," depends on ",(0,r.jsx)(n.code,{children:"cert-manager"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f https://github.com/jetstack/cert-manager/releases/latest/download/cert-manager.yaml\nkubectl wait --for=condition=Available deployment --timeout=2m -n cert-manager --all\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"entangle"})," needs to run on all the clusters that you wish to interconnect. It provides capabilities to interconnect services between clusters"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"entangle-proxy"})," only on the cluster that you wish to use as control cluster"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"install-the-crd-and-entangle",children:["Install the CRD and ",(0,r.jsx)(n.code,{children:"entangle"})]}),"\n",(0,r.jsx)(n.p,{children:"First, add the kairos helm repository:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"helm repo add kairos https://kairos-io.github.io/helm-charts\nhelm repo update\n"})}),"\n",(0,r.jsx)(n.p,{children:"Install the CRDs with:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"helm install kairos-crd kairos/kairos-crds\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Install ",(0,r.jsx)(n.code,{children:"entangle"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"helm install kairos-entangle kairos/entangle\n## To use a different image:\n## helm install kairos-entangle kairos/entangle --set image.serviceTag=v0.18.0 --set image.tag=latest\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"install-entangle-proxy",children:["Install ",(0,r.jsx)(n.code,{children:"entangle-proxy"})]}),"\n",(0,r.jsxs)(n.p,{children:["Now install ",(0,r.jsx)(n.code,{children:"entangle-proxy"})," only on the cluster which is used to control, and which dispatches manifests to downstream clusters."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"helm install kairos-entangle-proxy kairos/entangle-proxy\n"})}),"\n",(0,r.jsx)(n.h2,{id:"controlling-a-remote-cluster",children:"Controlling a remote cluster"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://user-images.githubusercontent.com/2420543/205872002-894f24aa-ac1c-4f70-bb46-aaad89392a25.png",alt:"control"})}),"\n",(0,r.jsxs)(n.p,{children:["To control a remote cluster, you need a cluster where to issue and apply manifest from (the control cluster, where ",(0,r.jsx)(n.code,{children:"entangle-proxy"})," is installed) and a cluster running ",(0,r.jsx)(n.code,{children:"entangle"})," which proxies ",(0,r.jsx)(n.code,{children:"kubectl"})," with a ",(0,r.jsx)(n.code,{children:"ServiceAccount"}),"/",(0,r.jsx)(n.code,{children:"Role"})," associated with it."]}),"\n",(0,r.jsxs)(n.p,{children:["They both need to agree on a secret, which is the ",(0,r.jsx)(n.code,{children:"network_token"})," to be able to communicate, otherwise it won't work. There is no other configuration needed in order for the two cluster to talk to each other."]}),"\n",(0,r.jsx)(n.h3,{id:"generating-a-network-token",children:"Generating a network token"}),"\n",(0,r.jsxs)(n.p,{children:["Generating a network token is described in ",(0,r.jsx)(n.a,{href:"../../installation/p2p",children:"the p2p section"})]}),"\n",(0,r.jsx)(n.h3,{id:"managed-cluster",children:"Managed cluster"}),"\n",(0,r.jsxs)(n.p,{children:["The cluster which is the target of our manifests, as specified needs to run a deployment which ",(0,r.jsx)(n.em,{children:"entangles"})," ",(0,r.jsx)(n.code,{children:"kubectl"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: Secret\nmetadata:\n  name: mysecret\n  namespace: default\ntype: Opaque\nstringData:\n  network_token: YOUR_NETWORK_TOKEN_GOES_HERE\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: entangle\n  namespace: default\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: entangle\nrules:\n- apiGroups:\n  - ""\n  resources:\n  - pods\n  verbs:\n  - create\n  - delete\n  - get\n  - list\n  - update\n  - watch\n\n- apiGroups:\n  - ""\n  resources:\n  - events\n  verbs:\n  - create\n---\napiVersion: v1\nkind: List\nitems:\n  - apiVersion: rbac.authorization.k8s.io/v1\n    kind: ClusterRoleBinding\n    metadata:\n      name: entangle\n    subjects:\n    - kind: ServiceAccount\n      name: entangle\n      namespace: default\n    roleRef:\n      kind: ClusterRole\n      name: entangle\n      apiGroup: rbac.authorization.k8s.io\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: agent-proxy\n  name: agent-proxy\n  namespace: default\nspec:\n  selector:\n    matchLabels:\n      app: agent-proxy\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: agent-proxy\n        entanglement.kairos.io/name: "mysecret"\n        entanglement.kairos.io/service: "foo"\n        entanglement.kairos.io/target_port: "8001"\n        entanglement.kairos.io/direction: "entangle"\n    spec:\n      serviceAccountName: entangle\n      containers:\n        - name: proxy\n          image: "quay.io/kairos/kubectl"\n          imagePullPolicy: Always\n          command: ["/usr/bin/kubectl"]\n          args:\n            - "proxy"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Note: replace ",(0,r.jsx)(n.em,{children:"YOUR_NETWORK_TOKEN_GOES_HERE"})," with the token generated with the ",(0,r.jsx)(n.code,{children:"kairos-cli"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"control",children:"Control"}),"\n",(0,r.jsxs)(n.p,{children:["To control, from the cluster that has ",(0,r.jsx)(n.code,{children:"entangle-proxy"})," installed we can apply:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: Secret\nmetadata:\n  name: mysecret\n  namespace: default\ntype: Opaque\nstringData:\n  network_token: YOUR_NETWORK_TOKEN_GOES_HERE\n---\napiVersion: entangle-proxy.kairos.io/v1alpha1\nkind: Manifests\nmetadata:\n  name: hello\n  namespace: default\n  labels:\n   entanglement.kairos.io/name: "mysecret"\n   entanglement.kairos.io/service: "foo"\n   entanglement.kairos.io/target_port: "9090"\nspec:\n   serviceUUID: "foo"\n   secretRef: "mysecret"\n   manifests:\n   - |\n      apiVersion: v1\n      kind: Pod\n      metadata:\n        name: test\n        namespace: default\n      spec:\n            containers:\n            - name: hello\n              image: busybox:1.28\n              command: [\'sh\', \'-c\', \'echo "Hello, ssaa!" && sleep 3600\']\n            restartPolicy: OnFailure\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Note: replace ",(0,r.jsx)(n.em,{children:"YOUR_NETWORK_TOKEN_GOES_HERE"})," with the token generated with the ",(0,r.jsx)(n.code,{children:"kairos-cli"})," and used in the step above."]}),"\n",(0,r.jsx)(n.h2,{id:"expose-services",children:"Expose services"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"entangle"})," CRD can be used to interconnect services of clusters, or create tunnels to cluster services."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Can inject a sidecar container to access a remote services exposed"}),"\n",(0,r.jsx)(n.li,{children:"Can create a deployment which exposes a remote service from another cluster"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"deployment",children:"Deployment"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"entangle"})," can be used to tunnel a connection or a service available from one cluster to another."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.img,{src:"https://user-images.githubusercontent.com/2420543/205871973-d913680d-355f-4322-8cbb-6a94f8505ccb.png",alt:"entangle-A"}),"\nIn the image above, we can see how entangle can create a tunnel for a service running on Cluster A and mirror it to to Cluster B."]}),"\n",(0,r.jsxs)(n.p,{children:["It can also expose services that are reachable from the host Network:\n",(0,r.jsx)(n.img,{src:"https://user-images.githubusercontent.com/2420543/205871999-17abcde8-1b78-4a71-bc3e-ed77664c5551.png",alt:"entangle-B"})]}),"\n",(0,r.jsxs)(n.p,{children:["Consider the following example that tunnels a cluster ",(0,r.jsx)(n.code,{children:"192.168.1.1:80"})," to another one using an ",(0,r.jsx)(n.code,{children:"Entanglement"}),":"]}),"\n","\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(l.A,{value:"cluster-a-(where-`192.168.1.1:80`-is-accessible)",label:"Cluster A (where `192.168.1.1:80` is accessible)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: Secret\nmetadata:\n  name: mysecret\n  namespace: default\ntype: Opaque\nstringData:\n  network_token: _YOUR_SECRET_GOES_HERE_\n---\napiVersion: entangle.kairos.io/v1alpha1\nkind: Entanglement\nmetadata:\n  name: test2\n  namespace: default\nspec:\n   serviceUUID: "foo2"\n   secretRef: "mysecret"\n   host: "192.168.1.1"\n   port: "80"\n   hostNetwork: true\n'})})}),(0,r.jsx)(l.A,{value:"cluster-b-(which-will-have-a-`clusterip`-available-on-the-kubernetes-service-network)",label:"Cluster B (which will have a `ClusterIP` available on the Kubernetes service network)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: mysecret\n  namespace: default\ntype: Opaque\nstringData:\n  network_token: _YOUR_SECRET_GOES_HERE_\n---\napiVersion: entangle.kairos.io/v1alpha1\nkind: Entanglement\nmetadata:\n  name: test3\n  namespace: default\nspec:\n   serviceUUID: "foo2"\n   secretRef: "mysecret"\n   host: "127.0.0.1"\n   port: "8080"\n   inbound: true\n   serviceSpec:\n    ports:\n    - port: 8080\n      protocol: TCP\n    type: ClusterIP\n'})})})]}),"\n",(0,r.jsx)(n.h3,{id:"sidecar-injection",children:"Sidecar injection"}),"\n",(0,r.jsx)(n.p,{children:"The controller can inject a container which exposes a connection (in both directions):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: Secret\nmetadata:\n  name: mysecret\n  namespace: default\ntype: Opaque\nstringData:\n  network_token: _YOUR_SECRET_GOES_HERE_\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: hello\n  namespace: default\n  labels:\n   # Here we use the labels to refer to the service on the network, and the secret which contains our network_token\n   entanglement.kairos.io/name: "mysecret"\n   entanglement.kairos.io/service: "foo"\n   entanglement.kairos.io/target_port: "9090"\nspec:\n      containers:\n      - name: hello\n        image: busybox:1.28\n        command: [\'sh\', \'-c\', \'echo "Hello, Kubernetes!" && sleep 3600\']\n      restartPolicy: OnFailure\n'})}),"\n",(0,r.jsx)(n.p,{children:"Or we can combine them together:"}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(l.A,{value:"cluster-a",label:"Cluster A",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: Secret\nmetadata:\n  name: mysecret\n  namespace: default\ntype: Opaque\nstringData:\n  network_token: _YOUR_SECRET_GOES_HERE_\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: entangle-proxy\n  name: entangle-proxy\n  namespace: default\nspec:\n  selector:\n    matchLabels:\n      app: entangle-proxy\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: entangle-proxy\n        entanglement.kairos.io/name: "mysecret"\n        entanglement.kairos.io/service: "foo"\n        entanglement.kairos.io/target_port: "8001"\n        entanglement.kairos.io/direction: "entangle"\n      name: entangle-proxy\n    spec:\n      containers:\n        - name: proxy\n          image: "quay.io/mudler/k8s-resource-scheduler:latest"\n          imagePullPolicy: Always\n          command: ["/usr/bin/kubectl"]\n          args:\n            - "proxy"\n'})})}),(0,r.jsx)(l.A,{value:"cluster-b",label:"Cluster B",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: Secret\nmetadata:\n  name: mysecret\n  namespace: default\ntype: Opaque\nstringData:\n  network_token: _YOUR_SECRET_GOES_HERE_\n---\napiVersion: entangle.kairos.io/v1alpha1\nkind: Entanglement\nmetadata:\n  name: test\n  namespace: default\nspec:\n   serviceUUID: "foo"\n   secretRef: "mysecret"\n   host: "127.0.0.1"\n   port: "8080"\n   inbound: true\n   serviceSpec:\n    ports:\n    - port: 8080\n      protocol: TCP\n    type: ClusterIP\n'})})})]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);