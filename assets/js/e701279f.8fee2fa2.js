"use strict";(globalThis.webpackChunkkairos_docs=globalThis.webpackChunkkairos_docs||[]).push([[9658],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(96540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},83723:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"Advanced/partition_encryption","title":"Encrypting User Data with Kairos","description":"This section describes how to encrypt partition with LUKS in Kairos.","source":"@site/docs/Advanced/partition_encryption.md","sourceDirName":"Advanced","slug":"/Advanced/partition_encryption","permalink":"/docs/next/Advanced/partition_encryption","draft":false,"unlisted":false,"editUrl":"https://github.com/kairos-io/kairos-docs/tree/main/docs/Advanced/partition_encryption.md","tags":[],"version":"current","lastUpdatedBy":"Jasper De Keukelaere (imec)","lastUpdatedAt":1765043763000,"sidebarPosition":5,"frontMatter":{"title":"Encrypting User Data with Kairos","sidebar_label":"Encrypting User Data with Kairos","sidebar_position":5,"description":"This section describes how to encrypt partition with LUKS in Kairos."},"sidebar":"tutorialSidebar","previous":{"title":"Bundles","permalink":"/docs/next/Advanced/bundles"},"next":{"title":"Confidential Computing","permalink":"/docs/next/Advanced/coco"}}');var i=t(74848),r=t(28453);const o={title:"Encrypting User Data with Kairos",sidebar_label:"Encrypting User Data with Kairos",sidebar_position:5,description:"This section describes how to encrypt partition with LUKS in Kairos."},a=void 0,c={},l=[{value:"Requirements",id:"requirements",level:2},{value:"Components",id:"components",level:2},{value:"Offline mode",id:"offline-mode",level:2},{value:"Scenario: Offline encryption",id:"scenario-offline-encryption",level:3},{value:"Online mode",id:"online-mode",level:2},{value:"Requirements",id:"requirements-1",level:3},{value:"Install the KMS (<code>kcrypt-challenger</code>)",id:"install-the-kms-kcrypt-challenger",level:3},{value:"Register a node",id:"register-a-node",level:3},{value:"Scenario: Automatically generated keys",id:"scenario-automatically-generated-keys",level:3},{value:"Scenario: Static keys",id:"scenario-static-keys",level:3},{value:"Discoverable Key Management Server (KMS)",id:"discoverable-key-management-server-kms",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Notes",id:"notes",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Kairos offers the ability to encrypt user data partitions with ",(0,i.jsx)(n.code,{children:"LUKS"}),". User-data partitions are dedicated to persist data for a running system, stored separately from the OS images. This encryption mechanism can also be used to encrypt additional partitions created during the installation process."]}),"\n",(0,i.jsx)(n.p,{children:"Kairos supports the following encryption scenarios:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Offline mode"})," - Encryption key for partitions is stored on the machine inside the TPM chip."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Online mode (Automated)"})," - Keypair used to encrypt the partition passphrase is stored on the TPM chip, and an external server is used to store the encrypted passphrases."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Online mode (Manually configured)"})," - Plaintext passphrase is stored in the KMS server and returned to the node after TPM challenging."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://user-images.githubusercontent.com/2420543/214405291-97a30f2d-d70a-45ba-b842-5282c722c79e.png",alt:"encryption1_1674470732563_0"})}),"\n",(0,i.jsxs)(n.p,{children:["Kairos uses the TPM chip to encrypt partition passphrases, and for offline encryption, it stores the passphrase in the non-volatile registries of the chip.",(0,i.jsx)(n.br,{}),"\n","To enable encryption, you will need to specify the labels of the partitions you want to encrypt, a minimum configuration for offline encryption can be seen below:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"#cloud-config\n\ninstall:\n  # Label of partitions to encrypt\n  # COS_PERSISTENT is the OS partition \n  # dedicated to user-persistent data.\n  encrypted_partitions:\n  - COS_PERSISTENT\n"})}),"\n",(0,i.jsx)(n.p,{children:"Please note that for online mode, you will also need to specify the key management server address that will be used to store the keys, a complete configuration reference is the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'#cloud-config\n\n# Install block\ninstall:\n  # Label of partitions to encrypt\n  # COS_PERSISTENT is the OS partition \n  # dedicated to user-persistent data.\n  encrypted_partitions:\n  - COS_PERSISTENT\n\n# Kcrypt configuration block\nkcrypt:\n  challenger:\n    # External KMS Server address. This must be reachable by the node\n    challenger_server: "http://192.168.68.109:30000"\n    # (optional) Custom Non-Volatile index to use to store encoded blobs\n    nv_index: ""\n    # (optional) Custom Index for the RSA Key pair\n    c_index: ""\n    # (optional) Custom TPM device\n    tpm_device: ""\n    # (optional) Instructs the client to lookup the KMS using mdns\n    mdns: false\n'})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Option"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"install.encrypted_partitions"})}),(0,i.jsx)(n.td,{children:"Label of partitions to encrypt"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kcrypt.challenger.challenger_server"})}),(0,i.jsx)(n.td,{children:"External KMS Server address"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kcrypt.challenger.nv_index"})}),(0,i.jsx)(n.td,{children:"Custom Non-Volatile index to use to store encoded blobs"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kcrypt.challenger.c_index"})}),(0,i.jsx)(n.td,{children:"Custom Index for the RSA Key pair"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kcrypt.challenger.tpm_device"})}),(0,i.jsx)(n.td,{children:"Custom TPM device"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"kcrypt.challenger.mdns"})}),(0,i.jsxs)(n.td,{children:["Discover KMS using mdns. Defaults to ",(0,i.jsx)(n.code,{children:"false"})]})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,i.jsxs)(n.p,{children:["The host machine must have a TPM chip version 2.0 or higher to use encryption with Kairos. A list of TPM chips/HW can be found ",(0,i.jsx)(n.a,{href:"https://trustedcomputinggroup.org/membership/certification/tpm-certified-products/",children:"in the list of certified products"}),", however, any modern machine has a TPM 2.0 chip."]}),"\n",(0,i.jsx)(n.h2,{id:"components",children:"Components"}),"\n",(0,i.jsx)(n.p,{children:"The Kairos encryption design involves three components to manage partitions encryption and decryption lifecycle:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/kairos-io/kcrypt",children:"kcrypt"})," runs on the machine and attempts to unlock partitions by using plugins to delegate encryption/decryption business logic."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/kairos-io/kcrypt-challenger",children:"kcrypt-discovery-challenger"})," runs on the machine, it is called by ",(0,i.jsx)(n.code,{children:"kcrypt"})," and uses the TPM chip to retrieve the passphrase as described below."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/kairos-io/kcrypt-challenger",children:"kcrypt-challenger"})," is the KMS (Key Management Server) component, deployed in Kubernetes, which manages secrets and partitions of the nodes."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"offline-mode",children:"Offline mode"}),"\n",(0,i.jsx)(n.p,{children:"This scenario covers encryption of data at rest without any third party or KMS server. The keys used to encrypt the partitions are stored in the TPM chip."}),"\n",(0,i.jsx)(n.h3,{id:"scenario-offline-encryption",children:"Scenario: Offline encryption"}),"\n",(0,i.jsx)(n.p,{children:"A high level overview of the interaction between the components can be observed here:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://user-images.githubusercontent.com/2420543/214795800-f7d54309-2a3c-4d29-b6da-c74644424244.png",alt:"offline"})}),"\n",(0,i.jsx)(n.p,{children:"A complete cloud config example for this scenario can be:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"#cloud-config\n\ninstall:\n  encrypted_partitions:\n  - COS_PERSISTENT\n\nhostname: metal-{{ trunc 4 .MachineID }}\nusers:\n- name: kairos\n  # Change to your pass here\n  passwd: kairos\n  groups:\n  - admin\n  ssh_authorized_keys:\n  # Replace with your github user and un-comment the line below:\n  # - github:mudler\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note, we define a list of partition labels that we want to encrypt. In the example above we set ",(0,i.jsx)(n.code,{children:"COS_PERSISTENT"})," to be encrypted, which in turns will encrypt all the user-data of the machine (this includes, for instance, Kubernetes pulled images, or any runtime persisting data on the machine)."]}),"\n",(0,i.jsx)(n.h2,{id:"online-mode",children:"Online mode"}),"\n",(0,i.jsxs)(n.p,{children:["Online mode involves an external service (the Key Management Server, ",(0,i.jsx)(n.strong,{children:"KMS"}),") to boot the machines. The KMS role is to enable machine to boot by providing the encrypted secrets, or passphrases to unlock the encrypted drive. Authentication with the KMS is done via TPM challenging."]}),"\n",(0,i.jsx)(n.p,{children:"In this scenario, we need to first deploy the KMS server to an existing Kubernetes cluster, and associate the TPM hash of the nodes that we want to manage. During deployment, we specify the KMS server inside the cloud-config of the nodes to be provisioned."}),"\n",(0,i.jsx)(n.h3,{id:"requirements-1",children:"Requirements"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A Kubernetes cluster"}),"\n",(0,i.jsx)(n.li,{children:"Kcrypt-challenger reachable by the nodes attempting to boot"}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"install-the-kms-kcrypt-challenger",children:["Install the KMS (",(0,i.jsx)(n.code,{children:"kcrypt-challenger"}),")"]}),"\n",(0,i.jsxs)(n.p,{children:["To install the KMS (",(0,i.jsx)(n.code,{children:"kcrypt-challenger"}),"), you will first need to make sure that certificate manager is installed. You can do this by running the following command:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"kubectl apply -f https://github.com/jetstack/cert-manager/releases/latest/download/cert-manager.yaml\nkubectl wait --for=condition=Available deployment --timeout=2m -n cert-manager --all\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To install ",(0,i.jsx)(n.code,{children:"kcrypt-challenger"})," on a Kubernetes cluster with ",(0,i.jsx)(n.code,{children:"helm"}),", you can use the commands below:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'# Install the helm repository\nhelm repo add kairos https://kairos-io.github.io/helm-charts\nhelm repo update\n\n# Install the Kairos CRDs\nhelm install kairos-crd kairos/kairos-crds\n\n# Deploy the KMS challenger\nhelm install kairos-challenger kairos/kairos-challenger --set service.challenger.type="NodePort"\n  \n# we can also set up a specific port and a version:\n# helm install kairos-challenger kairos/kairos-challenger --set image.tag="v0.2.2" --set service.challenger.type="NodePort" --set service.challenger.nodePort=30000\n'})}),"\n",(0,i.jsx)(n.p,{children:"A service must be used to expose the challenger. If using the node port, we can retrieve the address with:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"export EXTERNAL_IP=$(kubectl get nodes -o jsonpath='{.items[].status.addresses[?(@.type == \"ExternalIP\")].address}')\nexport PORT=$(kubectl get svc kairos-challenger-escrow-service -o json | jq '.spec.ports[0].nodePort')\n"})}),"\n",(0,i.jsx)(n.h3,{id:"register-a-node",children:"Register a node"}),"\n",(0,i.jsx)(n.p,{children:"In order to register a node on the KMS, the TPM hash of the node needs to be retrieved first. The TPM hash is a SHA256 sum of the EK public key, which is part of the EK key pair that is present on the TPM from the manufacturer. The EK private key cannot be changed and is unique to the TPM and therefore, the EK public key can be used to uniquely challenge the device. During the challenge, the node will send its public key to the challenger, which will generate a SHA256 checksum and compare it to a local database of checksums. In order to build this database, the checksum needs to be registered with the challenger."}),"\n",(0,i.jsxs)(n.p,{children:["You can get a node TPM hash by running ",(0,i.jsx)(n.code,{children:"/system/discovery/kcrypt-discovery-challenger"})," as root from the LiveCD:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"kairos@localhost:~> ID=$(sudo /system/discovery/kcrypt-discovery-challenger)\nkairos@localhost:~> echo $ID\n7441c78f1976fb23e6a5c68f0be35be8375b135dcb36fb03cecc60f39c7660bd\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This is the TPM hash you should use in the definition of the ",(0,i.jsx)(n.code,{children:"SealedVolume"})," in the examples below."]}),"\n",(0,i.jsx)(n.h3,{id:"scenario-automatically-generated-keys",children:"Scenario: Automatically generated keys"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://user-images.githubusercontent.com/2420543/214405310-78f7deec-b43e-4581-a99b-a358492cc7ac.png",alt:"encryption3_1674472162848_0"})}),"\n",(0,i.jsx)(n.p,{children:"The TPM chip generates unique RSA keys for each machine during installation, which are used to encrypt a generated secret. These keys can only be accessed by the TPM and not by the KMS, thus ensuring that both the KMS and the TPM chip are required to boot the machine. As a result, even if the machine or its disks are stolen, the drive remains sealed and encrypted.\nDeployment using this method, will store the encrypted key used to boot into the KMS, and the keypair used to encrypt it in the TPM chip of the machine during installation. This means that, only the TPM chip can decode the passphrase, and the passphrase is stored in the KMS such as it can't be decrypted by it. As such, nodes can boot only with the KMS, and the disk can be decrypted only by the node."}),"\n",(0,i.jsxs)(n.p,{children:["To register a node to kubernetes, use the TPM hash retrieved before (see section ",(0,i.jsx)(n.a,{href:"#register-a-node",children:'"Register a node"'}),")\nand replace it in this example command:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'cat <<EOF | kubectl apply -f -\napiVersion: keyserver.kairos.io/v1alpha1\nkind: SealedVolume\nmetadata:\n    name: test2\n    namespace: default\nspec:\n  TPMHash: "7441c78f1976fb23e6a5c68f0be35be8375b135dcb36fb03cecc60f39c7660bd"\n  partitions:\n    - label: COS_PERSISTENT\n  quarantined: false\nEOF\n'})}),"\n",(0,i.jsx)(n.p,{children:"This command will register the node on the KMS."}),"\n",(0,i.jsx)(n.p,{children:"A node can use the following during deployment, specifying the address of the challenger server:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'#cloud-config\n\ninstall:\n  encrypted_partitions:\n  - COS_PERSISTENT\n  grub_options:\n    extra_cmdline: "rd.neednet=1"\n\nkcrypt:\n  challenger:\n    challenger_server: "http://192.168.68.109:30000"\n    nv_index: ""\n    c_index: ""\n    tpm_device: ""\n\nhostname: metal-{{ trunc 4 .MachineID }}\nusers:\n- name: kairos\n  # Change to your pass here\n  passwd: kairos\n  groups:\n  - admin\n  ssh_authorized_keys:\n  # Replace with your github user and un-comment the line below:\n  # - github:mudler\n'})}),"\n",(0,i.jsx)(n.h3,{id:"scenario-static-keys",children:"Scenario: Static keys"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://user-images.githubusercontent.com/2420543/214405316-63882311-ca27-4b6e-9465-70d702ab6dc1.png",alt:"encryption4_1674472306435_0"})}),"\n",(0,i.jsxs)(n.p,{children:["In this scenario the Kubernetes administrator knows the passphrase of the nodes, and sets explicitly during configuration the passphrase for each partitions of the nodes. This scenario is suitable for cases when the passphrase needs to be carried over, and not to be tied specifically to the TPM chip.",(0,i.jsx)(n.br,{}),"\n","The TPM chip is still used for authentication a machine. The discovery-challenger needs still to know the TPM hash of each of the nodes before installation.",(0,i.jsx)(n.br,{}),"\n","To register a node to kubernetes, replace the ",(0,i.jsx)(n.code,{children:"TPMHash"})," in the following example with the TPM hash retrieved before, and specify a passphrase with a secret reference for the partition:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'cat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: Secret\nmetadata:\n  name: mysecret\n  namespace: default\ntype: Opaque\nstringData:\n  pass: "awesome-plaintext-passphrase"\n---  \napiVersion: keyserver.kairos.io/v1alpha1\nkind: SealedVolume\nmetadata:\n    name: test2\n    namespace: default\nspec:\n  TPMHash: "7441c78f1976fb23e6a5c68f0be35be8375b135dcb36fb03cecc60f39c7660bd"\n  partitions:\n    - label: COS_PERSISTENT\n      secret:\n       name: mysecret\n       path: pass\n  quarantined: false\nEOF\n'})}),"\n",(0,i.jsx)(n.p,{children:"The node doesn't need any specific configuration beside the kcrypt challenger, so for instance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'#cloud-config\n\ninstall:\n  encrypted_partitions:\n  - COS_PERSISTENT\n  grub_options:\n    extra_cmdline: "rd.neednet=1"\n\nkcrypt:\n  challenger:\n    challenger_server: "http://192.168.68.109:30000"\n    nv_index: ""\n    c_index: ""\n    tpm_device: ""\n\nhostname: metal-{{ trunc 4 .MachineID }}\nusers:\n- name: kairos\n  # Change to your pass here\n  passwd: kairos\n  groups:\n  - admin\n  ssh_authorized_keys:\n  # Replace with your github user and un-comment the line below:\n  # - github:mudler\n'})}),"\n",(0,i.jsx)(n.h2,{id:"discoverable-key-management-server-kms",children:"Discoverable Key Management Server (KMS)"}),"\n",(0,i.jsxs)(n.p,{children:["By setting ",(0,i.jsx)(n.code,{children:"kcrypt.challenger.mdns"})," to ",(0,i.jsx)(n.code,{children:"true"})," in the config, Kairos will try to\ndiscover the KMS using the ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Multicast_DNS",children:"mdns protocol"}),".\nFor that to work, the ",(0,i.jsx)(n.code,{children:"kcrypt.challenger.challenger_server"})," options should also\nbe a domain ending in ",(0,i.jsx)(n.code,{children:".local"}),". If a server exists in the same network and responds to the request,\nKairos will use the information from the response to connect to the server."]}),"\n",(0,i.jsxs)(n.p,{children:["The server running in the kubernetes cluster (See the ",(0,i.jsx)(n.a,{href:"#components",children:"Components section"}),") does not\nimplement the mDNS protocol and thus it won't respond to the client's request. That is because\nthe server is running inside Kubernetes, which has its own network and it won't receive\nthe client's broadcast message."]}),"\n",(0,i.jsxs)(n.p,{children:["A server is needed that runs in the same network as the Kairos node and responds\nwith the IP address and port where the KMS is reachable.\nThere may be tools that can be configured for the job, but we also provide a little\nutility that does exactly that: ",(0,i.jsx)(n.a,{href:"https://github.com/kairos-io/simple-mdns-server/",children:"https://github.com/kairos-io/simple-mdns-server/"})]}),"\n",(0,i.jsxs)(n.p,{children:["The process to deploy the KMS is similar to the ",(0,i.jsx)(n.a,{href:"#online-mode",children:"Online mode"}),".\nAn example on how to test this feature locally, can be found ",(0,i.jsx)(n.a,{href:"https://github.com/kairos-io/kcrypt-challenger/blob/main/mdns-notes",children:"in this document"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Invoking ",(0,i.jsx)(n.code,{children:"/system/discovery/kcrypt-discovery-challenger"})," without arguments returns the TPM pubhash."]}),"\n",(0,i.jsxs)(n.li,{children:["Invoking ",(0,i.jsx)(n.code,{children:"kcrypt-discovery-challenger"})," with 'discovery.password' triggers the logic to retrieve the passphrase, for instance can be used as such:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'echo \'{ "data": "{ \\"label\\": \\"LABEL\\" }"}\' | sudo /system/discovery/kcrypt-discovery-challenger "discovery.password"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The url of the KMS server is looked up in the kairos config (In directories",(0,i.jsx)(n.code,{children:"/oem"})," and ",(0,i.jsx)(n.code,{children:"/sysroot/oem"}),")."]}),"\n",(0,i.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,i.jsxs)(n.p,{children:["If encryption is enabled and ",(0,i.jsx)(n.code,{children:"COS_PERSISTENT"})," is set to be encrypted, every cloud config file in ",(0,i.jsx)(n.code,{children:"/usr/local/cloud-config"})," will be protected and can be used to store sensitive data. However, it's important to keep in mind that although the contents of /usr/local are retained between reboots and upgrades, they will not be preserved during a ",(0,i.jsx)(n.a,{href:"../../reference/reset",children:"resets"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);