"use strict";(globalThis.webpackChunkkairos_docs=globalThis.webpackChunkkairos_docs||[]).push([[6334],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(96540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},32110:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/kairos-over-wireguard-9f297b051ec38eef7fa75c960c5b2608.svg"},51419:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var i=s(77576),t=s(74848),r=s(28453);const o={authors:["dimitris-karakasilis"],slug:"home-lab-with-kairos-and-wireguard",tags:["kairos"],title:"Access your home-lab Kairos cluster over a Wireguard VPN"},a=void 0,l={authorsImageUrls:[void 0]},c=[{value:"The problem",id:"the-problem",level:2},{value:"A Solution",id:"a-solution",level:2},{value:"High level view",id:"high-level-view",level:3},{value:"Step by step",id:"step-by-step",level:3},{value:"Setup the cloud VM",id:"setup-the-cloud-vm",level:4},{value:"Setup the test machine (mobile?)",id:"setup-the-test-machine-mobile",level:4},{value:"Setup the cluster",id:"setup-the-cluster",level:4},{value:"Test the connection",id:"test-the-connection",level:4},{value:"Conclusion",id:"conclusion",level:3},{value:"Useful links",id:"useful-links",level:3}];function h(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"the-problem",children:"The problem"}),"\n",(0,t.jsx)(n.p,{children:"You got yourself a Raspberry Pi (or more), and you want to put them to good use.\nYou decide to make a Kubernetes cluster out of them, so that you can utilise the resources better, use familiar tools and implement infrastructure-as-code."}),"\n",(0,t.jsx)(n.p,{children:"Up to this point, kudos to you for demanding no less than a real cloud from your home infra."}),"\n",(0,t.jsxs)(n.p,{children:["Like a smart person you are, you probably used ",(0,t.jsx)(n.a,{href:"https://kairos.io/",children:"Kairos"})," to create your cluster and it's now  up and running.\nIt's now time to run some workloads."]}),"\n",(0,t.jsx)(n.p,{children:"Here is my list if you need some ideas:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A self-hosted Dropbox alternative (e.g. ",(0,t.jsx)(n.a,{href:"https://www.seafile.com/en/home/",children:"Seafile"}),", ",(0,t.jsx)(n.a,{href:"https://nextcloud.com/",children:"NextCloud"})," or other)"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://pi-hole.net/",children:"Pihole"})}),"\n",(0,t.jsxs)(n.li,{children:["An ",(0,t.jsx)(n.a,{href:"https://mqtt.org/",children:"mqtt"})," broker for your IoT projects"]}),"\n",(0,t.jsxs)(n.li,{children:["Your own ",(0,t.jsx)(n.a,{href:"https://gitea.io/en-us/",children:"Gitea"})," instance"]}),"\n",(0,t.jsxs)(n.li,{children:["Your own ChatGPT alternative (e.g. using ",(0,t.jsx)(n.a,{href:"https://github.com/go-skynet/llama-cli",children:"lama-cli"})," or ",(0,t.jsx)(n.a,{href:"https://github.com/nsarrazin/serge",children:"serge"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["None of these workloads is intended for public access. There are ways to expose the cluster to the world (e.g. like I described ",(0,t.jsx)(n.a,{href:"https://dimitris.karakasilis.me/2022/12/26/self-hosted-ci.html",children:"in another post"}),")\nbut it would be better if only devices within a VPN would have access to it."]}),"\n",(0,t.jsxs)(n.p,{children:["Once again, there are many VPN solutions out there, but for this blog post, we'll go with ",(0,t.jsx)(n.a,{href:"https://www.wireguard.com/",children:"Wireguard"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"So here is the problem in one sentence:"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:'"How do we expose our (possibly behind NAT) cluster, to machines inside the same Wireguard VPN?"'}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:'"NAT" is the main part of the problem because otherwise this would simply be a blog post on how to create a Wireguard VPN. There are many nice tutorials already out there for that.'})}),"\n",(0,t.jsx)(n.h2,{id:"a-solution",children:"A Solution"}),"\n",(0,t.jsx)(n.p,{children:"While trying to solve the problem, I learned 2 things about Wireguard that I didn't know:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:'Wireguard doesn\'t distinguish between a "server" and a "client". All peers are made equal.'}),"\n",(0,t.jsx)(n.li,{children:"Wireguard doesn't provide a solution for NAT traversal. How you access nodes behind NAT, is up to you."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"So imagine you have your cluster behind your home router (NAT) and your mobile phone on another network (behind NAT too) trying to access a service on the cluster.\nThat's not possible, unless there is some public IP address that somehow forwards requests to the cluster."}),"\n",(0,t.jsx)(n.p,{children:"And that's the idea this solution is based on."}),"\n",(0,t.jsx)(n.h3,{id:"high-level-view",children:"High level view"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Image describing the solution",src:s(32110).A+"",width:"890",height:"573"})}),"\n",(0,t.jsxs)(n.p,{children:["The idea is almost similar to the one I described ",(0,t.jsx)(n.a,{href:"https://dimitris.karakasilis.me/2022/12/26/self-hosted-ci.html",children:"in another post"}),".\nThe only difference is, that this time we expose the cluster only to machines inside the VPN."]}),"\n",(0,t.jsx)(n.p,{children:"Prerequisites:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A VM with a public IP address and SSH access (as small as it gets, it's good enough)"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"kubectl"})," access to the cluster we want to expose (it doesn't have to be Kairos, even ",(0,t.jsx)(n.a,{href:"https://k3d.io",children:(0,t.jsx)(n.code,{children:"k3d"})})," and ",(0,t.jsx)(n.a,{href:"https://kind.sigs.k8s.io/",children:(0,t.jsx)(n.code,{children:"kind"})})," will do)"]}),"\n",(0,t.jsx)(n.li,{children:"A machine to test the result (a smartphone where Wireguard can be installed is fine)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-by-step",children:"Step by step"}),"\n",(0,t.jsxs)(n.p,{children:["From this point on, we will use the IP address ",(0,t.jsx)(n.code,{children:"1.2.3.4"})," as the public IP address of the VM in the cloud.\nReplace it with the one matching your VM. We also assume, that the user with SSH access is ",(0,t.jsx)(n.code,{children:"root"}),". Replace if necessary."]}),"\n",(0,t.jsx)(n.h4,{id:"setup-the-cloud-vm",children:"Setup the cloud VM"}),"\n",(0,t.jsx)(n.p,{children:"SSH to the machine:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ ssh root@1.2.3.4\n"})}),"\n",(0,t.jsx)(n.p,{children:"Create Wireguard keys:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ wg genkey | tee privatekey | wg pubkey > publickey\n"})}),"\n",(0,t.jsx)(n.p,{children:"Create Wireguard config:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ cat << EOF > /etc/wireguard/wg0.conf\n[Interface]\nAddress = 192.168.6.1/24\nPrivateKey = $(cat privatekey)\nListenPort = 41194\n\n# Mobile client\n[Peer]\nPublicKey = <public key from next step>\nAllowedIPs = 192.168.6.2/32\nEOF\n"})}),"\n",(0,t.jsx)(n.p,{children:"Start and enable the Wireguard service:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"$ sudo systemctl enable --now wg-quick@wg0\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Allow binding non-loopback interfaces when creating an SSH reverse tunnel\nby setting ",(0,t.jsx)(n.code,{children:"GatewayPorts clientspecified"})," in ",(0,t.jsx)(n.code,{children:"/etc/ssh/sshd_config"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"setup-the-test-machine-mobile",children:"Setup the test machine (mobile?)"}),"\n",(0,t.jsxs)(n.p,{children:["On some computer with ",(0,t.jsx)(n.code,{children:"wg"})," installed, generate the keys:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ wg genkey | tee privatekey | wg pubkey > publickey\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Create the Wireguard configuration. Follow the instructions for your favorite application.\nFor Android, you can use this: ",(0,t.jsx)(n.a,{href:"https://play.google.com/store/apps/details?id=com.wireguard.android",children:"https://play.google.com/store/apps/details?id=com.wireguard.android"})]}),"\n",(0,t.jsx)(n.p,{children:"If setting up a Linux machine, you can create the configuration like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ cat << EOF > /etc/wireguard/wg0.conf\n[Interface]\nAddress = 192.168.6.2/24\nPrivateKey = $(cat privatekey)\n\n# The cloud VM\n[Peer]\nPublicKey = <public key from the previous step>\nAllowedIPs = 192.168.6.1/32\nEndpoint = 1.2.3.4:41194\nEOF\n"})}),"\n",(0,t.jsx)(n.p,{children:"Start and enable the Wireguard service. If on a Linux machine, something like this will do:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"$ sudo systemctl enable --now wg-quick@wg0\n"})}),"\n",(0,t.jsx)(n.p,{children:"On a mobile, follow the instructions of your application."}),"\n",(0,t.jsxs)(n.p,{children:["After a while, your client should be able to ping the IP address of the VM: ",(0,t.jsx)(n.code,{children:"192.168.6.1"}),".\nYou may find the output of ",(0,t.jsx)(n.code,{children:"wg show"})," useful, while waiting for the peers to connect."]}),"\n",(0,t.jsx)(n.h4,{id:"setup-the-cluster",children:"Setup the cluster"}),"\n",(0,t.jsxs)(n.p,{children:["Deploy the helper Pod. We will use an image created ",(0,t.jsx)(n.a,{href:"https://codeberg.org/dkarakasilis/self-hosted-ci/src/branch/main/image",children:"with this Dockerfile"})," and\npublished ",(0,t.jsx)(n.a,{href:"https://quay.io/repository/jimmykarily/nginx-ssh-reverse-proxy",children:"here"}),". The image's entrypoint works with a config\ndescribed ",(0,t.jsx)(n.a,{href:"https://codeberg.org/dkarakasilis/self-hosted-ci/src/commit/20d7c6cbf70cd5318309362b0897e6aeb9842b82/image/start.sh#L5-L27",children:"here"}),".\nThe image is not multiarch, but there is one suitable for RasberryPi 4 (see the comment in the file)."]}),"\n",(0,t.jsxs)(n.p,{children:["If you are are going to create a fresh Kairos cluster, you can use a config like the following to automatically set up the helper Pod (make sure you replace the ",(0,t.jsx)(n.code,{children:"id_rsa"})," and ",(0,t.jsx)(n.code,{children:"id_rsa.pub"})," keys).\nIf you prefer to not have the keys stored on your Kairos host filesystem, you can simply create the same resources using ",(0,t.jsx)(n.code,{children:"kubectl apply -f"})," after your cluster is up an running."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'#cloud-config\n\nusers:\n- name: kairos\n  passwd: kairos\n  groups:\n  - admin\n\nstages:\nafter-install-chroot:\n    - files:\n        - path: /var/lib/rancher/k3s/server/manifests/rproxy-pod.yaml\n        content: |\n        ---\n        apiVersion: v1\n        data:\n            id_rsa: the_vms_private_key_in_base64\n            id_rsa.pub: the_vms_public_key_in_base64\n        kind: Secret\n        metadata:\n            name: jumpbox-ssh-key\n        type: Opaque\n\n        ---\n        apiVersion: v1\n        kind: ConfigMap\n        metadata:\n            name: proxy-config\n        data:\n            config.json: |\n            {\n                "services": [\n                    {\n                    "bindIP": "192.168.6.1",\n                    "bindPort": "443",\n                    "proxyAddress": "traefik.kube-system.svc",\n                    "proxyPort": "443"\n                    },\n                    {\n                    "bindIP": "192.168.6.1",\n                    "bindPort": "80",\n                    "proxyAddress": "traefik.kube-system.svc",\n                    "proxyPort": "80"\n                    }\n                ],\n                "jumpbox": {\n                    "url": "1.2.3.4",\n                    "user": "root",\n                    "sshKeyFile": "/ssh/id_rsa"\n                }\n            }\n\n        ---\n        apiVersion: apps/v1\n        kind: Deployment\n        metadata:\n            annotations:\n            name: nginx-ssh-reverse-proxy\n        spec:\n            replicas: 1\n            selector:\n            matchLabels:\n                app.kubernetes.io/instance: nginx-ssh-reverse-proxy\n                app.kubernetes.io/name: nginx-ssh-reverse-proxy\n            template:\n            metadata:\n                labels:\n                    app.kubernetes.io/instance: nginx-ssh-reverse-proxy\n                    app.kubernetes.io/name: nginx-ssh-reverse-proxy\n            spec:\n                containers:\n                - name: proxy\n                    # Change to quay.io/jimmykarily/nginx-ssh-reverse-proxy-arm64:latest\n                    # if you are running on a RasberryPi 4\n                    image: quay.io/jimmykarily/nginx-ssh-reverse-proxy:latest\n                    command: ["/start.sh", "/proxy-config/config.json"]\n                    imagePullPolicy: Always\n                    volumeMounts:\n                    - name: ssh-key\n                    mountPath: /ssh\n                    - name: config-volume\n                    mountPath: /proxy-config/\n                volumes:\n                - name: ssh-key\n                    secret:\n                    secretName: jumpbox-ssh-key\n                    defaultMode: 0400\n                - name: proxy-config\n                - name: config-volume\n                    configMap:\n                    name: proxy-config\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"In a nutshell, the config above is creating a reverse SSH tunnel from the VM\nto the Pod. Inside the Pod, nginx redirects traffic to the traefik load balancer running\non the cluster. This has the effect, that any request landing on the VM on ports 80 and 443\nwill eventually reach the Traefik instance inside the cluster on ports 80 and 443.\nAs a result, you can point any domain you want to the VM and it will reach the corresponding Ingress defined on your cluster."}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"NOTE:"})," The SSH tunnel will only bind the IP address ",(0,t.jsx)(n.code,{children:"192.168.6.1"})," on the VM, which means, anyone trying to access the VM using its public IP address, will not be able to access the cluster. Only machines that can talk to ",(0,t.jsx)(n.code,{children:"192.168.6.1"})," have access, in other words, machines inside the VPN."]})}),"\n",(0,t.jsx)(n.h4,{id:"test-the-connection",children:"Test the connection"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Try to access the cluster with the VPN IP address (should work).\nFrom your test peer, open ",(0,t.jsx)(n.code,{children:"http://192.168.6.1"}),". You should see a 404 message from Traefik.\nYou can also verify it is a response from Traefik in your cluster, by calling curl\non the ",(0,t.jsx)(n.code,{children:"https"}),' endpoint (on a "default" k3s installation):']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ curl -k -v https://192.168.6.1 2>&1 | grep TRAEFIK\n*  subject: CN=TRAEFIK DEFAULT CERT\n*  issuer: CN=TRAEFIK DEFAULT CERT\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Try to access the cluster with domain pointing to the VPN IP address (should work)\nYou can create a wildcard DNS record and point it to the VPN IP address if\nyou want to make it easier for people to access the services you are running.\nE.g. by creating an A record like this: ",(0,t.jsx)(n.code,{children:"*.mydomainhere.org -> 192.168.6.1"}),"\nyou will be able create Ingresses for your applications like:\n",(0,t.jsx)(n.code,{children:"app1.mydomainhere.org"}),", ",(0,t.jsx)(n.code,{children:"app2.mydomainhere.org"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Try to access the cluster using the public IP address (should not work)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ curl http://1.2.3.4\n"})}),"\n",(0,t.jsx)(n.p,{children:"This command should fail to connect to your cluster"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"For non-critical workloads, when 100% uptime is not a hard requirement, the solution we described allows one to use services that would otherwise cost multiple times more by hosting\nthose on their own hardware. It does so, without exposing the home network to the public."}),"\n",(0,t.jsx)(n.p,{children:"If you liked this solution or if you have comments, questions or recommendations for improvements, please reach out!"}),"\n",(0,t.jsx)(n.h3,{id:"useful-links",children:"Useful links"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://kairos.io/docs/",children:"Kairos documentation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://www.wireguard.com/quickstart/",children:"WireGuard documentation"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},77576:e=>{e.exports=JSON.parse('{"permalink":"/kairos-docs/blog/home-lab-with-kairos-and-wireguard","editUrl":"https://github.com/kairos-io/kairos/tree/main/packages/create-kairos/templates/shared/blog/2023-03-29-home-lab-with-kairos-and-wireguard.md","source":"@site/blog/2023-03-29-home-lab-with-kairos-and-wireguard.md","title":"Access your home-lab Kairos cluster over a Wireguard VPN","description":"The problem","date":"2023-03-29T00:00:00.000Z","tags":[{"inline":false,"label":"Kairos","permalink":"/kairos-docs/blog/tags/kairos","description":"Posts about Kairos, an open-source, cloud-native, and immutable Linux distribution"}],"readingTime":7.58,"hasTruncateMarker":true,"authors":[{"name":"Dimitris Karakasilis","socials":{"github":"https://github.com/jimmykarily"},"url":"https://github.com/jimmykarily","imageURL":"https://github.com/jimmykarily.png","key":"dimitris-karakasilis","page":null}],"frontMatter":{"authors":["dimitris-karakasilis"],"slug":"home-lab-with-kairos-and-wireguard","tags":["kairos"],"title":"Access your home-lab Kairos cluster over a Wireguard VPN"},"unlisted":false,"prevItem":{"title":"Kairos release v2.0","permalink":"/kairos-docs/blog/release-v2.0"},"nextItem":{"title":"Understanding Immutable Linux OS: Benefits, Architecture, and Challenges","permalink":"/kairos-docs/blog/understanding-immutability"}}')}}]);