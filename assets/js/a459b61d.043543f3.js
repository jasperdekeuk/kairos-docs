"use strict";(globalThis.webpackChunkkairos_docs=globalThis.webpackChunkkairos_docs||[]).push([[4061],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},33541:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Advanced/revoking-secureboot-access","title":"Revoking secure boot access","description":"This document describes how an administrator can prevent certain OS images from","source":"@site/docs/Advanced/revoking-secureboot-access.md","sourceDirName":"Advanced","slug":"/Advanced/revoking-secureboot-access","permalink":"/docs/next/Advanced/revoking-secureboot-access","draft":false,"unlisted":false,"editUrl":"https://github.com/kairos-io/kairos-docs/tree/main/docs/Advanced/revoking-secureboot-access.md","tags":[],"version":"current","lastUpdatedBy":"Jasper De Keukelaere (imec)","lastUpdatedAt":1765043763000,"sidebarPosition":10,"frontMatter":{"title":"Revoking secure boot access","sidebar_label":"Revoking secure boot access","sidebar_position":10,"date":"2022-06-12T00:00:00.000Z"},"sidebar":"tutorialSidebar","previous":{"title":"Confidential Computing","permalink":"/docs/next/Advanced/coco"},"next":{"title":"Manual","permalink":"/docs/next/Upgrade/manual"}}');var s=t(74848),r=t(28453);const o={title:"Revoking secure boot access",sidebar_label:"Revoking secure boot access",sidebar_position:10,date:new Date("2022-06-12T00:00:00.000Z")},a=void 0,d={},c=[{value:"Scenario 1 - Signing certificate is no longer trusted",id:"scenario-1---signing-certificate-is-no-longer-trusted",level:2},{value:"From &quot;pem&quot; to &quot;auth&quot;",id:"from-pem-to-auth",level:3},{value:"PCRs and disk encryption",id:"pcrs-and-disk-encryption",level:3},{value:"Steps",id:"steps",level:3},{value:"Generate a new db cert",id:"generate-a-new-db-cert",level:4},{value:"Sign the new image with the new certificate",id:"sign-the-new-image-with-the-new-certificate",level:4},{value:"Enroll the new certificate in db",id:"enroll-the-new-certificate-in-db",level:4},{value:"Upgrade to the new image",id:"upgrade-to-the-new-image",level:4},{value:"Unbind PCR 7",id:"unbind-pcr-7",level:4},{value:"Enroll the old certificate in dbx",id:"enroll-the-old-certificate-in-dbx",level:4},{value:"Reboot to the upgraded image:",id:"reboot-to-the-upgraded-image",level:4},{value:"Bind again to PCR 11 and 7",id:"bind-again-to-pcr-11-and-7",level:4},{value:"Verifying that it worked",id:"verifying-that-it-worked",level:4},{value:"Upgrading recovery",id:"upgrading-recovery",level:4},{value:"Scenario 2 - One specific image is no longer trusted",id:"scenario-2---one-specific-image-is-no-longer-trusted",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["This document describes how an administrator can prevent certain OS images from\nbooting on their hardware in the context of ",(0,s.jsx)(n.a,{href:"../../architecture/trustedboot",children:'"Trusted Boot"'}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Two different scenarios will be covered, with the process being only slightly different for each case."}),"\n",(0,s.jsx)(n.h2,{id:"scenario-1---signing-certificate-is-no-longer-trusted",children:"Scenario 1 - Signing certificate is no longer trusted"}),"\n",(0,s.jsx)(n.p,{children:"The process of creating signed images that can be trusted to boot, requires the\nsigning keys to be safe and only accessible to the vendor that produces the OS images."}),"\n",(0,s.jsx)(n.p,{children:"In the unfortunate case in which a signing certificate has been compromised, it's\nimportant that the key is blacklisted on every machine.\nFailing to do so, will make it possible for the malicious actor with access to the key,\nto generate OS images that the system will accept to boot.\nThis will allow them boot and decrypt the filesystem, thus gaining full access\nto the data on that machine and full control over it."}),"\n",(0,s.jsx)(n.p,{children:'The UEFI firmware has a special "database" in which blacklisted certificates can\nbe "enrolled" (image hashes can also be enrolled, but more on that on the next scenario).'}),"\n",(0,s.jsxs)(n.p,{children:["If only one machine is running the signed OS images, and physical access to that machine is\npossible, then usually the simplest way is to boot into the machine's UEFI management utility\nand enroll the certificate in the ",(0,s.jsx)(n.code,{children:"dbx"})," database manually."]}),"\n",(0,s.jsx)(n.p,{children:"If this process has to be performed on thousands of machines remotely, then it's clear\nthat another approach is required."}),"\n",(0,s.jsxs)(n.p,{children:['Before going over the steps on how to "blacklist" a certificate by enrolling it\nin ',(0,s.jsx)(n.code,{children:"dbx"}),", here is some useful information which will make the steps more clear."]}),"\n",(0,s.jsx)(n.h3,{id:"from-pem-to-auth",children:'From "pem" to "auth"'}),"\n",(0,s.jsx)(n.p,{children:'The signing certificates are usually stored in one of the well known certificate\nformats, e.g. "pem". If a certificate is stored in a different format, it\'s usually\npossible to convert to "pem" with some utility. For this reason we will assume\nthe certificate is in the "pem" format from now on.'}),"\n",(0,s.jsx)(n.p,{children:'There are various utilities in Linux that allow enrolling certificates in the UEFI\ndatabases but they require those certs to be in a specific format usually in the\nESL (EFI Signature List) or the signed version of the same format, the "signed variables"\nformat. Using the signed version has the benefit that no private keys need to be present\nin order to do the enrollement, while using the unsigned format needs the private\nkeys to be present.'}),"\n",(0,s.jsxs)(n.p,{children:["If you followed ",(0,s.jsx)(n.a,{href:"../../Installation/trustedboot#key-generation",children:"the instructions to create signing keys"}),", you should have a directory with a ",(0,s.jsx)(n.code,{children:"db.pem"}),' certificate. This is the certificate\nwe will blacklist. To do so, we need to convert it to the "esl" format and then\nsign it to create the final ',(0,s.jsx)(n.code,{children:".auth"})," file, which will be used for enrollement.\nThe utilities used are usually shipped in the various distros under a name like ",(0,s.jsx)(n.code,{children:"efitools"})," (e.g. in Ubuntu). Here are the commands to generate the needed signed authenticated variables file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'export UUID=`uuidgen`\ncert-to-efi-sig-list -g "Kairos-$UUID" keys/db.pem db-dbx.esl\nsign-efi-sig-list -c keys/KEK.pem -k keys/KEK.key dbx db-dbx.esl db-dbx.auth\n'})}),"\n",(0,s.jsxs)(n.p,{children:["(Notice how we sign the ",(0,s.jsx)(n.code,{children:".auth"}),' file using the "KEK" key so that enrollement is allowed)']}),"\n",(0,s.jsx)(n.h3,{id:"pcrs-and-disk-encryption",children:"PCRs and disk encryption"}),"\n",(0,s.jsxs)(n.p,{children:["As described in the ",(0,s.jsx)(n.a,{href:"../../architecture/trustedboot",children:'"Trusted Boot"'})," documentation page,\nthe decryption of the disk partitions is bound to some PCR registers on the TPM chip.\nSpecifically registers 11 and 7.\nThere are 2 ways to bind to a PCR register, the direct and the indirect. You can\nread more in the ",(0,s.jsxs)(n.a,{href:"https://www.freedesktop.org/software/systemd/man/latest/systemd-cryptenroll.html#TPM2%20PCRs%20and%20policies",children:[(0,s.jsx)(n.code,{children:"systemd-cryptenroll"})," docs"]})," but in a nutshell, the indirect binding\nallows the actual value of the PCR to change while the direct one does not.\n",(0,s.jsx)(n.strong,{children:"For this reason, in Kairos, the decryption is bound indirectly to PCR 11 (which allows\nus to upgrade to newer kernels) and directly to PCR 7, which prevents booting if\nthe UEFI databases have been altered, e.g. by enrolling a new key."})]}),"\n",(0,s.jsxs)(n.p,{children:["And although this makes sense, security wise, it's exactly what we are trying to achieve here. We\nwant to enroll a certificate in ",(0,s.jsx)(n.code,{children:"dbx"}),". This would change the value of PCR 7 thus\ndecryption of the disk partitions will no longer be possible after reboot."]}),"\n",(0,s.jsx)(n.p,{children:"The method we use to overcome this issue is this:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'We "unbind" decryption from PCR 7, binding only to PCR 11 indirectly.'}),"\n",(0,s.jsx)(n.li,{children:"We enroll the blacklisted cert in dbx."}),"\n",(0,s.jsx)(n.li,{children:"We reboot to the upgraded system."}),"\n",(0,s.jsx)(n.li,{children:"We bind decryption again both to PCR 11 and 7 (as before)."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When we rebind to PCR 7, the register has the new value which includes the cert in dbx."}),"\n",(0,s.jsx)(n.h3,{id:"steps",children:"Steps"}),"\n",(0,s.jsxs)(n.p,{children:["With the above now clarified, here are the steps to revoke the ",(0,s.jsx)(n.code,{children:"db.pem"})," certificate from user space in Kairos."]}),"\n",(0,s.jsx)(n.h4,{id:"generate-a-new-db-cert",children:"Generate a new db cert"}),"\n",(0,s.jsxs)(n.p,{children:["Since it's only the db key that we are trying to replace, we can start by copying\nthe original directory generated by ",(0,s.jsx)(n.code,{children:"auroraboot genkey"})," and remove the old db files."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cp keys new-keys\nrm new-keys/db.*\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now create the new db files:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'uuidgen --random > GUID.txt\nopenssl req -newkey rsa:4096 -nodes -keyout db.key -new -x509 -sha256 -days 3650 -subj "/CN=NewKairosDB/" -out db.crt\nopenssl x509 -outform DER -in db.crt -out db.cer\ncert-to-efi-sig-list -g "$(< GUID.txt)" db.crt db.esl\nsign-efi-sig-list -g "$(< GUID.txt)" -k KEK.key -c KEK.pem db db.esl db.auth\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If you are planning to use ",(0,s.jsx)(n.code,{children:"auroraboot build-uki"})," command to prepare the new OS image,\ncreate the following formats too or the command might complain if they are missing:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ openssl x509 -outform der -in db.crt -out db.der\n$ openssl x509 -inform DER -outform PEM -in db.der -out db.pem\n"})}),"\n",(0,s.jsx)(n.h4,{id:"sign-the-new-image-with-the-new-certificate",children:"Sign the new image with the new certificate"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"new-keys"})," directory created above can be used to prepare the new image with ",(0,s.jsx)(n.code,{children:"auroraboot"}),". E.g."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'docker run --rm -v $PWD/unpacked:/unpacked \\\n  -v $PWD/build:/result \\\n  -v $PWD/new-keys/:/keys \\\n  quay.io/kairos/auroraboot:latest \\\n  build-uki \\\n  --output-dir /result \\\n  --keys /keys \\\n  --output-type container \\\n  --boot-branding "KairosNewUKI" \\\n  dir:/unpacked\n'})}),"\n",(0,s.jsx)(n.h4,{id:"enroll-the-new-certificate-in-db",children:"Enroll the new certificate in db"}),"\n",(0,s.jsx)(n.p,{children:"From withing Kairos (still booted in the old image), enroll the new db key:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo chattr -i /sys/firmware/efi/efivars/{PK,KEK,db}*\nefi-updatevar -f db.auth db\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"Warning",type:"warning",children:(0,s.jsxs)(n.p,{children:["You will need the ",(0,s.jsx)(n.code,{children:"efitools"})," installed on the Kairos image for this commands to work!"]})}),"\n",(0,s.jsx)(n.h4,{id:"upgrade-to-the-new-image",children:"Upgrade to the new image"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"kairos-agent upgrade --source oci:myimage\n"})}),"\n",(0,s.jsx)(n.h4,{id:"unbind-pcr-7",children:"Unbind PCR 7"}),"\n",(0,s.jsx)(n.p,{children:"Bind partition encryption only to PCR 11 policy. From within Kairos again:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'echo "Generating temporary passphrase"\ndd if=/dev/random bs=32 count=1 of=/tmp/random_keyfile\n\necho "Adding password slot"\n# We temporarily switch to a passphrase decryption here, so that we can remove the "tpm" decryption\n# option below. After we add the "tpm" option back (bound to different PCR registers),\n# we remove the passphrase again.\ncryptsetup luksAddKey --token-type systemd-tpm2 /dev/vda2 /tmp/random_keyfile\ncryptsetup luksAddKey --token-type systemd-tpm2 /dev/vda3 /tmp/random_keyfile\n\necho "Removing the tpm2 slot"\nsystemd-cryptenroll /dev/vda2 --wipe-slot=tpm2\nsystemd-cryptenroll /dev/vda3 --wipe-slot=tpm2\n\necho "Adding tpm2 slot again (pcr 11 policy only, no pcr 7)"\nsystemd-cryptenroll --unlock-key-file=/tmp/random_keyfile --tpm2-public-key=/run/systemd/tpm2-pcr-public-key.pem --tpm2-public-key-pcrs=11 --tpm2-pcrs= --tpm2-signature=/run/systemd/tpm2-pcr-signature.json --tpm2-device-key=/run/systemd/tpm2-srk-public-key.tpm2b_public /dev/vda2\nsystemd-cryptenroll --unlock-key-file=/tmp/random_keyfile --tpm2-public-key=/run/systemd/tpm2-pcr-public-key.pem --tpm2-public-key-pcrs=11 --tpm2-pcrs= --tpm2-signature=/run/systemd/tpm2-pcr-signature.json --tpm2-device-key=/run/systemd/tpm2-srk-public-key.tpm2b_public /dev/vda3\n\necho "Removing the password slot"\nsystemd-cryptenroll --wipe-slot=password /dev/vda2\nsystemd-cryptenroll --wipe-slot=password /dev/vda3\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Make sure you use the correct device paths for your encrypted partitions\n(",(0,s.jsx)(n.code,{children:"/dev/vda2"})," and ",(0,s.jsx)(n.code,{children:"/dev/vda3"})," in the example)."]}),"\n",(0,s.jsx)(n.h4,{id:"enroll-the-old-certificate-in-dbx",children:"Enroll the old certificate in dbx"}),"\n",(0,s.jsxs)(n.p,{children:["As describe earlier in this document, you should generate a ",(0,s.jsx)(n.code,{children:"db-dbx.auth"})," file\nfrom the old db key. This should now be enrolled in dbx. In user space again\n(booted in the old Kairos image):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo efi-updatevar -f db-dbx.auth dbx\n"})}),"\n",(0,s.jsx)(n.h4,{id:"reboot-to-the-upgraded-image",children:"Reboot to the upgraded image:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"reboot\n"})}),"\n",(0,s.jsx)(n.h4,{id:"bind-again-to-pcr-11-and-7",children:"Bind again to PCR 11 and 7"}),"\n",(0,s.jsx)(n.p,{children:"After rebooting to the upgraded image, bind the encryption again to PCR 7 (and 11):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'echo "Generating temporary passphrase"\ndd if=/dev/random bs=32 count=1 of=/tmp/random_keyfile\n\necho "Adding password slot"\ncryptsetup luksAddKey --token-type systemd-tpm2 /dev/vda2 /tmp/random_keyfile\ncryptsetup luksAddKey --token-type systemd-tpm2 /dev/vda3 /tmp/random_keyfile\n\necho "Removing the tpm2 slot"\nsystemd-cryptenroll /dev/vda2 --wipe-slot=tpm2\nsystemd-cryptenroll /dev/vda3 --wipe-slot=tpm2\n\necho "Adding tpm2 slot again (pcr 11 policy AND pcr 7)"\necho "There is probably a bug in systemd preventing us from using the --tpm2-device-key"\necho "giving this error: \'Must provide all PCR values when using TPM2 device key.\'"\necho "coming from here: https://github.com/systemd/systemd/blob/7c6028bbcbd03f91e1c4b84dcf46b45e9672c2b6/src/cryptenroll/cryptenroll-tpm2.c#L362"\necho "so we\'ll opt for --tpm-device=auto"\necho "The command that fails was originally tried in this script:"\necho "https://github.com/kairos-io/kairos/issues/2429#issuecomment-2136728261"\nsystemd-cryptenroll --unlock-key-file=/tmp/random_keyfile --tpm2-public-key=/run/systemd/tpm2-pcr-public-key.pem --tpm2-public-key-pcrs=11 --tpm2-pcrs=7 --tpm2-signature=/run/systemd/tpm2-pcr-signature.json --tpm2-device=auto /dev/vda2\nsystemd-cryptenroll --unlock-key-file=/tmp/random_keyfile --tpm2-public-key=/run/systemd/tpm2-pcr-public-key.pem --tpm2-public-key-pcrs=11 --tpm2-pcrs=7 --tpm2-signature=/run/systemd/tpm2-pcr-signature.json --tpm2-device=auto /dev/vda3\n\necho "Removing the password slot"\nsystemd-cryptenroll --wipe-slot=password /dev/vda2\nsystemd-cryptenroll --wipe-slot=password /dev/vda3\n'})}),"\n",(0,s.jsx)(n.p,{children:"The following command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'cryptsetup luksDump /dev/vda2 | grep "pcrs: "\n'})}),"\n",(0,s.jsx)(n.p,{children:"should show output similar to this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\ttpm2-hash-pcrs:   7\n\ttpm2-pubkey-pcrs: 11\n"})}),"\n",(0,s.jsx)(n.p,{children:"which means the decryption is now bound again to PCR 7 (directly) and PCR 11 (indirectly)."}),"\n",(0,s.jsx)(n.p,{children:"This command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"systemd-cryptenroll /dev/vda2\n"})}),"\n",(0,s.jsxs)(n.p,{children:["should only show ",(0,s.jsx)(n.code,{children:"tmp2"})," (and not ",(0,s.jsx)(n.code,{children:"password"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:["(same thing for ",(0,s.jsx)(n.code,{children:"/dev/vda3"}),")"]}),"\n",(0,s.jsx)(n.p,{children:"You can now reboot to check if everything works correctly"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"reboot\n"})}),"\n",(0,s.jsx)(n.h4,{id:"verifying-that-it-worked",children:"Verifying that it worked"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Check what keys are enrolled in UEFI db:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"mokutil --list-enrolled --db | grep -E 'Issuer:|Subject:'\n"})}),"\n",(0,s.jsx)(n.p,{children:"You should find your new certificate in the list"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Check if the old certificate is in dbx:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"mokutil --list-enrolled --dbx | grep -E 'Issuer:|Subject:'\n"})}),"\n",(0,s.jsx)(n.p,{children:"You should find your old certificate in the list."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Check that the old images are not bootable"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'Just reboot and when presented with the boot menu, select "fallback" or "recovery".\nSince those images haven\'t been upgraded yet, they are still signed with the old\ncertificate. They should not boot and UEFI should show an error.'}),"\n",(0,s.jsx)(n.h4,{id:"upgrading-recovery",children:"Upgrading recovery"}),"\n",(0,s.jsxs)(n.p,{children:['After successfully booting to "active", you can now upgrade ',(0,s.jsx)(n.code,{children:"recovery"})," to make\ncan still boot if the next update goes wrong."]}),"\n",(0,s.jsx)(n.p,{children:"Obviously the recovery image will also need to be signed with the new certificate."}),"\n",(0,s.jsx)(n.p,{children:"The upgrade command is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"kairos-agent upgrade --recovery --source oci:<YOUR_UPGRADE_IMAGE_HERE>\n"})}),"\n",(0,s.jsxs)(n.p,{children:['The "fallback" image will be upgraded on the next upgrade. Read the ',(0,s.jsx)(n.a,{href:"../../architecture/container",children:'"Container based"'}),"\ndocument to understand more."]}),"\n",(0,s.jsx)(n.h2,{id:"scenario-2---one-specific-image-is-no-longer-trusted",children:"Scenario 2 - One specific image is no longer trusted"}),"\n",(0,s.jsx)(n.p,{children:"In the previous scenario, we assumed that the signing certificate was compromised, which meant no image signed by that certificate should be bootable anymore."}),"\n",(0,s.jsx)(n.p,{children:'In this scenario, only one specific image is considered "bad". For example, an image shipped with a well known security vulnerability.\nIn order to prevent this image from booting, its "hash" can be blacklisted.'}),"\n",(0,s.jsxs)(n.p,{children:["The process is exactly the same as above, but instead of enrolling a certificate in the ",(0,s.jsx)(n.code,{children:"dbx"})," database, we will enroll an image hash."]}),"\n",(0,s.jsxs)(n.p,{children:["Follow the same instructions as in scenario 1, but skipping the steps where a new ",(0,s.jsx)(n.code,{children:"db"})," key is created."]}),"\n",(0,s.jsxs)(n.p,{children:["To generate the file which will be enrolled to ",(0,s.jsx)(n.code,{children:"dbx"}),", we need access to the ",(0,s.jsx)(n.code,{children:".efi"})," image.\nIf there is a system still running the image that is going to be blacklisted,\nthe file will be: ",(0,s.jsx)(n.code,{children:"/efi/EFI/kairos/active.efi"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Since the image is not considered safe (that's the reason for blacklisting it after all),\nit's advisable to not boot it or use it for the calculation. If it's possible,\nboot from another, safe image, mount the efi partition and find the ",(0,s.jsx)(n.code,{children:"active.efi"})," file\non the disk."]}),"\n",(0,s.jsxs)(n.p,{children:['As a last option, if you still have access to the original install ISO that was used to\ninstall the "bad" image, you can extract the ',(0,s.jsx)(n.code,{children:".efi"})," file from that using standard linux tools."]}),"\n",(0,s.jsxs)(n.p,{children:["The steps to generate the ",(0,s.jsx)(n.code,{children:".auth"})," file are (assumes you have ",(0,s.jsx)(n.code,{children:"efitools"})," installed):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# generate the esl file\nhash-to-efi-sig-list /efi/EFI/kairos/active.efi active.esl\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now ",(0,s.jsx)(n.code,{children:"scp"})," that file to the machine where you have access to the image signing keys generated by auroraboot.\nThe command to sign the ",(0,s.jsx)(n.code,{children:"esl"})," file is similar to the one for the certificates:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sign-efi-sig-list -c keys/KEK.pem -k keys/KEK.key dbx active.esl active.auth\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"active.auth"})," is the file that should be enrolled to ",(0,s.jsx)(n.code,{children:"dbx"}),", exactly like we did with the ",(0,s.jsx)(n.code,{children:"db-dbx.auth"})," file\nin the previous scenario. The rest of the steps are similar."]}),"\n",(0,s.jsx)(n.p,{children:"Always keep in mind that after enrolling something (key or hash) to dbx, blacklisted OSes won't boot.\nMake sure you have successfully completed all the needed steps before you reboot, otherwise you may not be able to boot."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);