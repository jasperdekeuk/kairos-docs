"use strict";(globalThis.webpackChunkkairos_docs=globalThis.webpackChunkkairos_docs||[]).push([[4471],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(96540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}},81227:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"Examples/bandwidth-optimized-upgrades","title":"Bandwidth Optimized Upgrades","description":"This section describes how to optimize bandwidth usage during OS upgrades using distributed caching solutions.","source":"@site/docs/Examples/bandwidth-optimized-upgrades.md","sourceDirName":"Examples","slug":"/Examples/bandwidth-optimized-upgrades","permalink":"/kairos-docs/docs/next/Examples/bandwidth-optimized-upgrades","draft":false,"unlisted":false,"editUrl":"https://github.com/kairos-io/kairos-docs/tree/main/docs/Examples/bandwidth-optimized-upgrades.md","tags":[],"version":"current","lastUpdatedBy":"Jasper De Keukelaere (imec)","lastUpdatedAt":1765187035000,"frontMatter":{"title":"Bandwidth Optimized Upgrades","sidebar_label":"Bandwidth Optimized Upgrades","description":"This section describes how to optimize bandwidth usage during OS upgrades using distributed caching solutions."},"sidebar":"tutorialSidebar","previous":{"title":"Airgapped ISO","permalink":"/kairos-docs/docs/next/Examples/airgap"},"next":{"title":"Bundles","permalink":"/kairos-docs/docs/next/Examples/bundles"}}');var r=s(74848),t=s(28453);const o={title:"Bandwidth Optimized Upgrades",sidebar_label:"Bandwidth Optimized Upgrades",description:"This section describes how to optimize bandwidth usage during OS upgrades using distributed caching solutions."},a="Introduction",d={},l=[{value:"K3s with Embedded Registry (Spegel)",id:"k3s-with-embedded-registry-spegel",level:2},{value:"Manual Setup",id:"manual-setup",level:3},{value:"Master Node Configuration",id:"master-node-configuration",level:4},{value:"Worker Node Configuration",id:"worker-node-configuration",level:4},{value:"Auto Configuration",id:"auto-configuration",level:3},{value:"Upgrade Process with Distributed Caching",id:"upgrade-process-with-distributed-caching",level:3},{value:"Upgrade Configuration",id:"upgrade-configuration",level:4},{value:"Upgrade Process Flow",id:"upgrade-process-flow",level:4},{value:"K0s with Spegel",id:"k0s-with-spegel",level:2},{value:"Manual Setup",id:"manual-setup-1",level:3},{value:"Master Node Configuration",id:"master-node-configuration-1",level:4},{value:"Worker Node Configuration",id:"worker-node-configuration-1",level:4},{value:"Installing Spegel",id:"installing-spegel",level:3},{value:"Upgrade Process",id:"upgrade-process",level:3},{value:"Upgrade Process Flow",id:"upgrade-process-flow-1",level:4}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.admonition,{title:"Info",type:"info",children:(0,r.jsx)(n.p,{children:"This tutorial demonstrates how to optimize bandwidth usage during OS upgrades using distributed caching solutions like embedded registries."})}),"\n",(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,r.jsx)(n.p,{children:"Nodes in edge clusters often have poor networking capabilities, and Kairos users may create custom images that are significantly larger (e.g., by including many kernel drivers). The current issue is that during upgrades, each node in the cluster must re-download the entire image from scratch before applying the upgrade."}),"\n",(0,r.jsx)(n.p,{children:"This documentation explores solutions to optimize bandwidth usage during upgrades by implementing distributed caching mechanisms."}),"\n",(0,r.jsx)(n.h1,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Large Images"}),": Custom images can be very large due to additional drivers, tools, or configurations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Poor Network"}),": Edge nodes often have limited or unreliable network connectivity"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Redundant Downloads"}),": Each node downloads the same upgrade image independently"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bandwidth Waste"}),": Multiple nodes downloading identical images consumes unnecessary bandwidth"]}),"\n"]}),"\n",(0,r.jsx)(n.h1,{id:"solutions",children:"Solutions"}),"\n",(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:'Currently the solutions described here focus on "standard" Kairos images \u2014 images that include a Kubernetes distribution (e.g., K3s or K0s).'})}),"\n",(0,r.jsx)(n.h2,{id:"k3s-with-embedded-registry-spegel",children:"K3s with Embedded Registry (Spegel)"}),"\n",(0,r.jsxs)(n.p,{children:["K3s integrates with ",(0,r.jsx)(n.a,{href:"https://github.com/k3s-io/spegel",children:"Spegel"}),", a distributed registry that enables efficient image caching across your cluster. This integration allows nodes to share container images locally, reducing bandwidth usage and improving deployment speed."]}),"\n",(0,r.jsx)(n.admonition,{title:"Info",type:"info",children:(0,r.jsxs)(n.p,{children:["For detailed information about k3s embedded registry configuration, see the ",(0,r.jsx)(n.a,{href:"https://docs.k3s.io/installation/registry-mirror",children:"official k3s documentation"}),"."]})}),"\n",(0,r.jsx)(n.h3,{id:"manual-setup",children:"Manual Setup"}),"\n",(0,r.jsx)(n.h4,{id:"master-node-configuration",children:"Master Node Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'#cloud-config\n\nhostname: metal-{{ trunc 4 .MachineID }}\nusers:\n- name: kairos # Change to your own user\n  passwd: kairos # Change to your own password\n  groups:\n    - admin # This user needs to be part of the admin group\n\ninstall:\n  reboot: true\n\nk3s:\n  enabled: true\n  embedded_registry: true\n\nstages:\n  boot:\n    - name: "Add registries configuration for k3s/spegel"\n      files:\n        - path: /etc/rancher/k3s/registries.yaml\n          content: |\n            mirrors:\n              "*":\n'})}),"\n",(0,r.jsx)(n.h4,{id:"worker-node-configuration",children:"Worker Node Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'#cloud-config\n\nhostname: metal-{{ trunc 4 .MachineID }}\nusers:\n- name: kairos # Change to your own user\n  passwd: kairos # Change to your own password\n  groups:\n    - admin # This user needs to be part of the admin group\n\nk3s-agent: # Warning: the key is different from the master node one\n  enabled: true\n  args:\n    - --with-node-id # will configure the agent to use the node ID to communicate with the master node\n  env:\n    K3S_TOKEN: "YOUR_K3S_TOKEN_HERE" # Replace with the actual token from your master node\n    K3S_URL: https://YOUR_MASTER_NODE_IP:6443 # Replace with your master node\'s IP address\n\nstages:\n  boot:\n    - name: "Add registries configuration for k3s/spegel"\n      files:\n        - path: /etc/rancher/k3s/registries.yaml\n          content: |\n            mirrors:\n              "*":\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Important Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Replace ",(0,r.jsx)(n.code,{children:"YOUR_K3S_TOKEN_HERE"})," with the actual token from your master node"]}),"\n",(0,r.jsxs)(n.li,{children:["Replace ",(0,r.jsx)(n.code,{children:"YOUR_MASTER_NODE_IP"})," with your master node's IP address"]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"embedded_registry: true"})," setting enables Spegel integration"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"auto-configuration",children:"Auto Configuration"}),"\n",(0,r.jsx)(n.p,{children:"For automated cluster setup with P2P coordination:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'#cloud-config\n\nhostname: metal-{{ trunc 4 .MachineID }}\nusers:\n- name: kairos # Change to your own user\n  passwd: kairos # Change to your own password\n  groups:\n    - admin # This user needs to be part of the admin group\n\nk3s:\n  embedded_registry: true\n\np2p:\n  # Disabling DHT makes co-ordination to discover nodes only in the local network\n  disable_dht: true #Enabled by default\n\n  # network_token is the shared secret used by the nodes to co-ordinate with p2p.\n  # Setting a network token implies auto.enable = true.\n  # To disable, just set auto.enable = false\n  network_token: "YOUR_P2P_NETWORK_TOKEN_HERE" # Replace with your P2P network token\n\nstages:\n  boot:\n    - name: "Add registries configuration for k3s/spegel"\n      files:\n        - path: /etc/rancher/k3s/registries.yaml\n          content: |\n            mirrors:\n              "*":\n'})}),"\n",(0,r.jsx)(n.h3,{id:"upgrade-process-with-distributed-caching",children:"Upgrade Process with Distributed Caching"}),"\n",(0,r.jsx)(n.p,{children:"When performing upgrades, the embedded registry provides significant benefits:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Master Node First"}),": The upgrade starts on the master node, which pulls the upgrade image"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Distributed Caching"}),": The image is cached in the embedded registry"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Worker Nodes"}),": When worker nodes start their upgrade, they fetch the image from the local registry instead of pulling from remote"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"upgrade-configuration",children:"Upgrade Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'apiVersion: operator.kairos.io/v1alpha1\nkind: NodeOpUpgrade\nmetadata:\n  name: kairos-upgrade\n  namespace: default\nspec:\n  # The container image containing the new Kairos version\n  image: quay.io/kairos/opensuse:tumbleweed-latest-standard-amd64-generic-v3.5.0-k3s-v1.33.2-k3s1\n\n  # NodeSelector to target specific nodes (optional)\n  nodeSelector:\n    matchLabels:\n      kairos.io/managed: "true"\n\n  # Maximum number of nodes that can run the upgrade simultaneously\n  # 0 means run on all nodes at once\n  concurrency: 1\n\n  # Whether to stop creating new jobs when a job fails\n  # Useful for canary deployments\n  stopOnFailure: true\n'})}),"\n",(0,r.jsx)(n.h4,{id:"upgrade-process-flow",children:"Upgrade Process Flow"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Master Node Upgrade"}),": The master node pulls the upgrade image from the remote registry"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Registry Caching"}),": The image is automatically cached in the embedded Spegel registry"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Worker Node Upgrades"}),": Worker nodes fetch the image from the local registry, avoiding duplicate downloads"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bandwidth Efficiency"}),": Only one node downloads the image from remote, others use the local cache"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"k0s-with-spegel",children:"K0s with Spegel"}),"\n",(0,r.jsxs)(n.p,{children:["K0s can be configured with Spegel for distributed image caching, following the ",(0,r.jsx)(n.a,{href:"https://spegel.dev/docs/getting-started/#k0s",children:"official Spegel documentation for k0s"}),". This setup requires specific containerd configuration that must be explicitly created in the cloud-config."]}),"\n",(0,r.jsx)(n.h3,{id:"manual-setup-1",children:"Manual Setup"}),"\n",(0,r.jsx)(n.h4,{id:"master-node-configuration-1",children:"Master Node Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"#cloud-config\n\nhostname: metal-{{ trunc 4 .MachineID }}\nusers:\n- name: kairos # Change to your own user\n  passwd: kairos # Change to your own password\n  groups:\n    - admin # This user needs to be part of the admin group\n\nk0s:\n  enabled: true\n"})}),"\n",(0,r.jsx)(n.h4,{id:"worker-node-configuration-1",children:"Worker Node Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'#cloud-config\n\nhostname: metal-{{ trunc 4 .MachineID }}\nusers:\n- name: kairos # Change to your own user\n  passwd: kairos # Change to your own password\n  groups:\n    - admin # This user needs to be part of the admin group\n\nk0s-worker:\n  enabled: true\n  args:\n    - --token-file /etc/k0s/token\n\nwrite_files:\n  - path: /etc/k0s/token\n    permissions: 0644\n    content: |\n      <TOKEN> # generate it on your master node by running `k0s token create --role=worker`\n  - path: /etc/k0s/containerd.d/spegel.toml\n    permissions: 0644\n    content: |\n      [plugins."io.containerd.grpc.v1.cri".registry]\n        config_path = "/etc/containerd/certs.d"\n      [plugins."io.containerd.grpc.v1.cri".containerd]\n        discard_unpacked_layers = false\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Important Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Replace ",(0,r.jsx)(n.code,{children:"<TOKEN>"})," with the actual token from your master node (generate it by running ",(0,r.jsx)(n.code,{children:"k0s token create --role=worker"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["The containerd configuration file ",(0,r.jsx)(n.code,{children:"/etc/k0s/containerd.d/spegel.toml"})," must be explicitly created to enable Spegel compatibility"]}),"\n",(0,r.jsxs)(n.li,{children:["This configuration follows the ",(0,r.jsx)(n.a,{href:"https://spegel.dev/docs/getting-started/#k0s",children:"official Spegel k0s documentation"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"installing-spegel",children:"Installing Spegel"}),"\n",(0,r.jsx)(n.p,{children:"After your k0s cluster is running, install Spegel using the Helm chart with k0s-specific paths:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"helm upgrade --create-namespace --namespace spegel --install spegel oci://ghcr.io/spegel-org/helm-charts/spegel \\\n  --set spegel.containerdSock=/run/k0s/containerd.sock \\\n  --set spegel.containerdContentPath=/var/lib/k0s/containerd/io.containerd.content.v1.content\n"})}),"\n",(0,r.jsx)(n.h3,{id:"upgrade-process",children:"Upgrade Process"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'apiVersion: operator.kairos.io/v1alpha1\nkind: NodeOpUpgrade\nmetadata:\n  name: kairos-upgrade\n  namespace: default\nspec:\n  # The container image containing the new Kairos version\n  image: quay.io/kairos/opensuse:leap-15.6-standard-amd64-generic-v3.5.0-k0s-v1.33.3-k0s.0\n\n  # NodeSelector to target specific nodes (optional)\n  nodeSelector:\n    matchLabels:\n      kairos.io/managed: "true"\n\n  # Maximum number of nodes that can run the upgrade simultaneously\n  # 0 means run on all nodes at once\n  concurrency: 1\n\n  # Whether to stop creating new jobs when a job fails\n  # Useful for canary deployments\n  stopOnFailure: true\n'})}),"\n",(0,r.jsx)(n.h4,{id:"upgrade-process-flow-1",children:"Upgrade Process Flow"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"First Node Upgrade"}),": The first node pulls the upgrade image from the remote registry"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Spegel Caching"}),": The image is automatically cached in the Spegel distributed registry"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Subsequent Node Upgrades"}),": When the second and subsequent nodes start their upgrade, they fetch the image from the local Spegel registry instead of pulling from remote"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bandwidth Efficiency"}),": Only the first node downloads the image from remote, others use the local cache"]}),"\n"]}),"\n",(0,r.jsx)(n.h1,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"./k3s-stages",children:"K3s Stages"})," - Running stages with k3s"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/kairos-docs/docs/next/Examples/cluster-setup/multi-node",children:"Multi-node Setup"})," - Setting up multi-node clusters"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/kairos-docs/docs/next/Examples/cluster-setup/single-node-p2p",children:"P2P Examples"})," - P2P coordination examples"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);