"use strict";(globalThis.webpackChunkkairos_docs=globalThis.webpackChunkkairos_docs||[]).push([[2033],{5742:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Advanced/customizing","title":"Customizing the system image","description":"Learn how to customize Kairos images to suit your needs","source":"@site/versioned_docs/version-3.5.7/Advanced/customizing.md","sourceDirName":"Advanced","slug":"/Advanced/customizing","permalink":"/kairos-docs/docs/3.5.7/Advanced/customizing","draft":false,"unlisted":false,"editUrl":"https://github.com/kairos-io/kairos-docs/tree/main/versioned_docs/version-3.5.7/Advanced/customizing.md","tags":[],"version":"3.5.7","lastUpdatedBy":"Jasper De Keukelaere (imec)","lastUpdatedAt":1765142882000,"sidebarPosition":2,"frontMatter":{"title":"Customizing the system image","sidebar_label":"Customization","sidebar_position":2,"description":"Learn how to customize Kairos images to suit your needs"},"sidebar":"tutorialSidebar","previous":{"title":"Creating Custom Cloud Images","permalink":"/kairos-docs/docs/3.5.7/Advanced/creating_custom_cloud_images"},"next":{"title":"Private registries authentication","permalink":"/kairos-docs/docs/3.5.7/Advanced/private_registry_auth"}}');var o=t(74848),s=t(28453);const a={title:"Customizing the system image",sidebar_label:"Customization",sidebar_position:2,description:"Learn how to customize Kairos images to suit your needs"},r=void 0,d={},c=[{value:"Customizing the Kernel",id:"customizing-the-kernel",level:2},{value:"Customizing the file system hierarchy using custom mounts.",id:"customizing-the-file-system-hierarchy-using-custom-mounts",level:2},{value:"Bind mounts",id:"bind-mounts",level:3},{value:"Ephemeral mounts",id:"ephemeral-mounts",level:3},{value:"Customizing the file system hierarchy using cloud-config.",id:"customizing-the-file-system-hierarchy-using-cloud-config",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.admonition,{title:"Note",type:"info",children:(0,o.jsxs)(n.p,{children:["This guide focuses on customizing Kairos images. For a complete guide on creating custom cloud images from scratch, including when and how to apply these customizations, see ",(0,o.jsx)(n.a,{href:"./creating_custom_cloud_images",children:"Creating Custom Cloud Images"}),"."]})}),"\n",(0,o.jsxs)(n.p,{children:["Kairos is an open source, container-based operating system. To modify Kairos and add a package, you'll need to build a container image from the ",(0,o.jsx)(n.a,{href:"../../reference/image_matrix",children:"Kairos images"}),". Here's an example with Docker which adds ",(0,o.jsx)(n.code,{children:"figlet"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-dockerfile",children:"FROM quay.io/kairos/kairos-standard:latest\n\nRUN zypper in -y figlet\n\nRUN export VERSION=\"my-version\"\nRUN envsubst '${VERSION}' </etc/os-release\n"})}),"\n",(0,o.jsx)(n.p,{children:"After creating your Dockerfile, you can build your own image by running the following command:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'$ docker build -t docker.io/<yourorg>/myos:0.1 .\nSending build context to Docker daemon  2.048kB\nStep 1/3 : FROM quay.io/kairos/kairos-standard:latest\n ---\x3e 897dc0cddf91\nStep 2/3 : RUN zypper install -y figlet\n ---\x3e Using cache\n ---\x3e d57ff48546e7\nStep 3/3 : RUN MY_VERSION="my-version" >> /etc/os-release\n ---\x3e Running in b7bcb24969f5\nRemoving intermediate container b7bcb24969f5\n ---\x3e ca21930a4585\nSuccessfully built ca21930a4585\nSuccessfully tagged <your-org>/myos:0.1\n'})}),"\n",(0,o.jsx)(n.p,{children:"Once you have built your image, you can publish it to Docker Hub or another registry with the following command:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"$ docker push <your-org>/myos:0.1\nThe push refers to repository [docker.io/<your-org>/myos]\nc58930881bc4: Pushed\n7111ee985500: Pushed\n...\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You can use your custom image when ",(0,o.jsx)(n.a,{href:"../../upgrade/manual",children:"upgrading nodes manually"}),", ",(0,o.jsx)(n.a,{href:"../../upgrade/kubernetes",children:"with Kubernetes"})," or ",(0,o.jsx)(n.a,{href:"../../examples/core",children:"specifying it in the cloud-config during installation"}),". Here's how to do it manually with the ",(0,o.jsx)(n.code,{children:"kairos-agent"})," command:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"node:/home/kairos # kairos-agent upgrade --image docker.io/<your-org>/myos:0.1\nINFO[2022-12-01T13:49:41Z] kairos-agent version v0.0.1\nINFO[2022-12-01T13:49:42Z] Upgrade called\nINFO[2022-12-01T13:49:42Z] Applying 'before-upgrade' hook\nINFO[2022-12-01T13:49:42Z] Running before-upgrade hook\nINFO[2022-12-01T13:49:42Z] deploying image docker.io/oz123/myos:0.1 to /run/initramfs/cos-state/cOS/transition.img\nINFO[2022-12-01T13:49:42Z] Creating file system image /run/initramfs/cos-state/cOS/transition.img\nINFO[2022-12-01T13:49:42Z] Copying docker.io/oz123/myos:0.1 source...\nINFO[0000] Unpacking a container image: docker.io/oz123/myos:0.1\nINFO[0000] Pulling an image from remote repository\n...\nINFO[2022-12-01T13:52:33Z] Finished moving /run/initramfs/cos-state/cOS/transition.img to /run/initramfs/cos-state/cOS/active.img \nINFO[2022-12-01T13:52:33Z] Upgrade completed\nINFO[2022-12-01T13:52:33Z] Upgrade completed\n\nnode:/home/kairos # which figlet\nwhich: no figlet in (/sbin:/usr/sbin:/usr/local/sbin:/root/bin:/usr/local/bin:/usr/bin:/bin)\nnode:/home/kairos # reboot\n\n"})}),"\n",(0,o.jsx)(n.p,{children:"Now, reboot your OS and ssh again to it to use figlet:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"$ ssh -l kairos node:\nWelcome to Kairos!\n\nRefer to https://kairos.io for documentation.\nkairos@node2:~> figlet kairos rocks!\n _         _                                _        _\n| | ____ _(_)_ __ ___  ___   _ __ ___   ___| | _____| |\n| |/ / _` | | '__/ _ \\/ __| | '__/ _ \\ / __| |/ / __| |\n|   < (_| | | | | (_) \\__ \\ | | | (_) | (__|   <\\__ \\_|\n|_|\\_\\__,_|_|_|  \\___/|___/ |_|  \\___/ \\___|_|\\_\\___(_)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"customizing-the-kernel",children:"Customizing the Kernel"}),"\n",(0,o.jsxs)(n.p,{children:["Kairos allows you to customize the kernel and initrd as part of your container-based operating system. If you are using a glibc-based distribution, such as OpenSUSE or Ubuntu, you can use the distribution's package manager to replace the kernel with the one you want, and then rebuild the initramfs with ",(0,o.jsx)(n.code,{children:"dracut"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Here's an example of how to do this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:'# Replace the existing kernel with a new one, depending on the base image it can differ\napt-get install -y ...\n\n# Create the kernel symlink\nkernel=$(ls /boot/vmlinuz-* | head -n1)\nln -sf "${kernel#/boot/}" /boot/vmlinuz\n\n# Regenerate the initrd, in openSUSE we could just use "mkinitrd"\nkernel=$(ls /lib/modules | head -n1)\ndracut -v -f "/boot/initrd-${kernel}" "${kernel}"\nln -sf "initrd-${kernel}" /boot/initrd\n\n# Update the module dependencies\nkernel=$(ls /lib/modules | head -n1)\ndepmod -a "${kernel}"\n'})}),"\n",(0,o.jsxs)(n.p,{children:["After you have modified the kernel and initrd, you can use the kairos-agent upgrade command to update your nodes, or ",(0,o.jsx)(n.a,{href:"../../upgrade/kubernetes",children:"within Kubernetes"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"customizing-the-file-system-hierarchy-using-custom-mounts",children:"Customizing the file system hierarchy using custom mounts."}),"\n",(0,o.jsx)(n.h3,{id:"bind-mounts",children:"Bind mounts"}),"\n",(0,o.jsxs)(n.p,{children:["For clusters that needs to mount network block storage you might want to add\ncustom mount point that bind mounted to your system. For example, when using\nCeph file system, the OS mounts drives to ",(0,o.jsx)(n.code,{children:"/var/lib/ceph"})," (for example)."]}),"\n",(0,o.jsxs)(n.p,{children:["To achieve this you need to add the key ",(0,o.jsx)(n.code,{children:"bind_mounts"})," to the ",(0,o.jsx)(n.code,{children:"install"})," section\nyou pass the install, and specify a list of one or more bind mounts path."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'install:\n  auto: true\n  device: "auto"\n  # changes persist reboot  - mount as BIND\n  bind_mounts:\n  - /var/lib/ceph\n...\n'})}),"\n",(0,o.jsxs)(n.p,{children:["To do this after installation, simply add a cloud config file in the ",(0,o.jsx)(n.code,{children:"/oem"})," folder, for instance, to make ",(0,o.jsx)(n.code,{children:"/var/lib/docker"})," persistent:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'#cloud-config\n\nstages:\n  rootfs:\n  - name: "user_custom_mount"\n    environment_file: "/run/cos/custom-layout.env"\n    environment:\n       CUSTOM_BIND_MOUNTS: "/var/lib/docker"\n'})}),"\n",(0,o.jsx)(n.h3,{id:"ephemeral-mounts",children:"Ephemeral mounts"}),"\n",(0,o.jsxs)(n.p,{children:["One can also specifying custom mounts which are ephemeral. These are writable,\nhowever changes are discarded at boot (like ",(0,o.jsx)(n.code,{children:"/etc/"})," already does)."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'install:\n  auto: true\n  device: "auto"\n  # changes persist reboot  - mount as BIND\n  bind_mounts:\n  - /var/lib/ceph\n  ephemeral_mounts:\n  - /opt/scratch/\n...\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Note, that these paths should exist in the container file-system used to create the ISO.\nSee ",(0,o.jsx)(n.a,{href:"../../Advanced/customizing",children:"ISO customization"})," above."]}),"\n",(0,o.jsx)(n.h2,{id:"customizing-the-file-system-hierarchy-using-cloud-config",children:"Customizing the file system hierarchy using cloud-config."}),"\n",(0,o.jsx)(n.p,{children:"For cases in which there is specific disk or mount needs,\nwe can leverage cloud-config to do very specific things that may not be covered by the custom mount facility that we mention above."}),"\n",(0,o.jsx)(n.p,{children:"For example, if we wanted to mount an extra disk into a specific path in the root that doesn't exists we could do it with a config like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'#cloud-config\n\ninstall:\n  auto: true\n  reboot: true\n  device: /dev/vda\n\nstages:\n  after-install-chroot: # Creates the data dir after install inside the final system chroot\n    - &createdatadir\n      name: "Create data dir"\n      commands:\n        - mkdir -p /data\n    # Formats the disk ONLY after-install and just once. Extra checks can be added here, so we don\'t reformat it\n    # This can also go in the after-install stage, but its just important to do it just once\n    - name: "Format /dev/vdb"\n      commands:\n        - mkfs.ext4 -F /dev/vdb\n  # Creates the data dir after reset inside the final system chroot, just in case it\'s not there\n  after-reset-chroot:\n    - <<: *createdatadir\n  # Creates the data dir after upgrade inside the final system chroot, just in case it\'s not there\n  after-upgrade-chroot:\n    - <<: *createdatadir\n  initramfs:\n    # Mounts the disk under the /data dir during initramfs on each boot, with RW. Extra options can be added to the mount here\n    - name: "Mount /dev/vdb under /data"\n      commands:\n        - mount -o rw /dev/vdb /data\n'})}),"\n",(0,o.jsxs)(n.p,{children:["This would leverage the ",(0,o.jsx)(n.code,{children:"kairos-agent"})," stages ",(0,o.jsx)(n.code,{children:"after-install-chroot"}),", ",(0,o.jsx)(n.code,{children:"after-upgrade-chroot"})," and ",(0,o.jsx)(n.code,{children:"after-reset-chroot"})," to\ncreate a new folder in the rootfs, format the given disk and mount it during the ",(0,o.jsx)(n.code,{children:"initramfs"})," stage."]}),"\n",(0,o.jsxs)(n.p,{children:["This works because during the ",(0,o.jsx)(n.code,{children:"after-install-chroot"}),", ",(0,o.jsx)(n.code,{children:"after-upgrade-chroot"})," and ",(0,o.jsx)(n.code,{children:"after-reset-chroot"})," stages we run any commands\ninside the final system with a chroot AND we have RW access during that time. We could use those same stages to install extra packages for example,\nbut in this case we use it to create an extra path. Remember that once we have installed, the system is inmmutable, so we won't be able to create\nany new paths in the root filesystem during runtime, even when using cloud-config. Only ephemeral and persistent paths are RW during runtime."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(96540);const o={},s=i.createContext(o);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);